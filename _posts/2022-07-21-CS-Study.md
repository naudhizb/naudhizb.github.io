---
layout: post
title: "C# 스터디 자료"
tags: [C#, Study]
comments: true
---

# C# Study

## C#이란? 

C#은 마이크로소프트에서 개발된 객체 지향 프로그래밍 언어로서 Java나 C++와 비슷한 면들을 가지고 있다. C#과 .NET Framework와 매우 밀접한 관계를 가지고 있어 대부분의 C#언어 개발은 .NET Framework 기반으로 개발된다. 
C#은 윈도우, 웹, 게임 및 모바일 프로그래밍 등 모든 영역에서 사용되는 범용 프로그래밍 언어이다. 확장자로 .cs 확장자를 사용하여 윈도우 환경에서는 csc.exe 프로그램을 이용하여 C#파일을 실행파일을 생성 할 수 있다. 


## C# 주요 문법

문법을 공부하기에 앞서 기본 프로그래밍 예제인 Hello World를 작성하고 실행하여 보자. 

**Hello world 예제**

아래와 같이 프로그램을 작성하여 Hello World를 출력하는 프로그램을 작성할 수 있다. 

```cs
namespace ConsoleApp1
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hello World...");
        }
    }
}
```

### 주석(Comment)

C#언어의 주석은 C언어와 동일한 주석 구조를 사용한다. 

```cs

// 한줄 주석입니다. 
/* 영역 주석입니다
   두번째 줄 */
```

### 네임스페이스(namespace)

.NET Framework은 무수하게 많은 클래스들을 가지고 있는데, 예를 들면 .NET 4.0은 약 11,000개의 클래스를 가지고 있다. 이렇게 많은 클래스들을 충돌없이 보다 편리하게 관리/사용하기 위해 .NET에서 네임스페이스를 사용한다. C#에서도 이러한 개념을 적용하여 클래스들이 대개 네임스페이스 안에서 정의된다. 비록 클래스가 네임스페이스 없이도 정의 될 수는 있지만, 거의 모든 경우 네임스페이스를 정의하는 것이 일반적이다.

#### 네임스페이스 참조

네임스페이스를 사용하기 위해서는 두가지 방식이 있다. 첫째는 클래스명 앞에 네임스페이스 전부를 적는 경우와 둘째는 프로그램 맨 윗단에 해당 using을 사용하여 C# (.cs) 파일에서 사용하고자 하는 네임스페이스를 한번 설정해 주고, 이후 해당 파일 내에서 네임스페이스 없이 직접 클래스를 사용하는 경우이다. 실무에서는 주로 두번째 방식을 사용한다.

```cs
//첫번째 방식
static void Main(string[] args)
{
    System.Console.WriteLine();
}

//두번째 방식
using System; //System 네임스페이스 지정

static void Main(string[] args)
{
    Console.WriteLine();
}
```

### Value Type / Reference Type

C#은 Value Type과 Reference Type을 지원한다. C#에서는 struct를 사용하면 Value Type을 만들고, class 를 사용하면 Reference Type을 만든다.

C# .NET의 기본 데이타형들은 struct로 정의되어 있다. 즉, int, double, float, bool 등의 기본 데이타 타입은 모두 struct로 정의된 Value Type이다. Value Type은 상속될 수 없으며, 주로 상대적으로 간단한 데이타 값을 저장하는데 사용된다.

Reference Type은 class를 정의하여 만들며 상속이 가능하고, 좀 더 복잡한 데이타와 행위들을 정의하는 곳에 많이 사용된다. Value Type의 파라미터 전달은 데이타를 복사(copy)하여 전달하는 반면, Reference Type은 Heap 상의 객체에 대한 레퍼런스(reference)를 전달하여 이루어진다. 구현에 있어 어떤 Type을 선택하는가는 해당 Type의 특성을 고려해서 결정해야 하는 문제이다.

```cs
// System.Int32 (Value Type)
public struct Int32 
{ 
   //....
}

// System.String (Reference Type)
public sealed class String 
{
   //....
}
```

### C# 데이터 타입

C#에서는 아래와 같은 기본 데이터 타입들을 지원한다. 

|C# 데이터 타입|.NET 데이터 타입|설명|
|---|---|:---|
|bool	|System.Boolean	|True or False|
|byte	|System.Byte	|8비트 unsigned integer|
|sbyte	|System.SByte	|8비트 signed integer|
|short	|System.Int16	|16비트 signed integer|
|int	|System.Int32	|32비트 signed integer|
|long	|System.Int64	|64비트 signed integer|
|ushort	|System.UInt16	|16비트 unsigned integer|
|uint	|System.UInt32	|32비트 unsigned integer|
|ulong	|System.UInt64	|64비트 unsigned integer|
|float	|System.Single	|32비트 single precision 부동소수점 숫자|
|double	|System.Double	|64비트 double precision 부동소수점 숫자|
|decimal	|System.Decimal	|128비트 Decimal|
|char	|System.Char	|16비트 유니코드 문자|
|string	|System.String	|유니코드 문자열|
|   |System.DateTime	|날짜와 시간, 별도의 C# 키워드가 없음|
|object	|System.Object	|모든 타입의 기본 클래스로 모든 유형을 포함할 수 있음|

#### C# Anonymous Type (익명 타입)

C#에서 어떤 클래스를 사용하기 위해서는 일반적으로 먼저 클래스를 정의한 후 사용한다. 하지만 C# 3.0부터 클래스를 미리 정의하지 않고 사용할 수 있게 하는 익명타입(Anonymous Type)을 지원하게 되었다. Anonymous Type은 new { ... } 와 같은 형식을 사용하며, new 블럭안에 속성=값 할당을 하고, 각 속성/값은 콤마로 분리한다.

Anonymous Type은 읽기 전용이므로 속성값을 갱신할 수는 없다. C# 키워드 var는 컴파일러가 타입을 추론해서 찾아내도록 할 때 사용되는데, 익명 타입 객체를 변수에 할당할 때는 특별히 타입명이 없으므로 var를 사용한다. 컴파일러는 익명 타입에 대해 내부적으로 임의의 클래스를 생성하여 사용하게 된다.

```cs
// 익명 타입 : new { 속성1=값, 속성2=값; }
   
var t = new { Name="홍길동", Age=20 };
string s = t.Name;
```

Anonymous Type은 공식적으로 클래스를 정의할 필요 없이 Type을 간단히 임시로 만들어 사용할 때 유용하다. 특히 Anonymous Type은 LINQ를 사용할 때 많이 사용된다.
아래 예제는 LINQ의 Where() 메서드를 이용해 특정 조건의 데이타를 찾은 후, Select() 메서드를 사용하여 일부 컬럼들로만 구성된 새 익명 타입을 만들어 리턴하는 예를 보여주고 있다.

```cs
private void RunTest()
{
    var v = new[] {
        new { Name="Lee", Age=33, Phone="02-111-1111" },
        new { Name="Kim", Age=25, Phone="02-222-2222" },
        new { Name="Park", Age=37, Phone="02-333-3333" },
    };

    // LINQ Select를 이용해 Name과 Age만 갖는 새 익명타입 객체들을 리턴.
    var list = v.Where(p => p.Age >= 30).Select(p => new { p.Name, p.Age });
    foreach (var a in list)
    {
        Debug.WriteLine(a.Name + a.Age);
    }
}
```

### C# 리터럴

값이 미리 정해져 있는 123, 12.3, "A", true 등의 데이터를 리터럴이라 한다. 리터럴 데이터를 사용할 때 접미어(Suffix)를 사용하지 않으면 컴파일러가 타입을 결정한다. 만약 사용자가 특정 데이터 타입으로 리터럴을 선언하고 싶은 경우에는 접미어를 이용하여 데이터 타입을 지정하여야 한다. 

|C# 리터럴 데이타 타입|	Suffix (대소문자 모두 가능)|	예제|
|:---|---|:---|
|long	|L	|1024L|
|uint	|U	|1024U|
|ulong	|UL	|1024UL|
|float	|F	|10.24F|
|double	|D	|10.24D 또는 10.24|
|decimal	|M	|10.24M|

### Nullable Type


C#에서 정수, 부동자릿수, 구조체 등의 Value Type은 NULL을 가질 수 없다. 예를 들어, 정수 int i 가 있을 때 변수 i에는 null을 할당할 수 없으며, 따라서 변수 i는 어떤 값이 할당되지 않은 상태 (missing value)를 가질 수 없다.
만약 정수형 변수 i에 값이 설정되지 않은 상태를 할당하려면, 개발자는 2가지 방법을 사용할 수 있을 것이다. 즉, (1)프로그램에서 사용될 것 같지 않은 특정 값을 추정하여 할당하던지 (예를 들어, int i = int.MaxValue;) (2) 아니면 또 하나의 변수를 두어 변수 i가 missing임을 나타내게 할 수 있다 (예를 들어, bool iHasValue = false;). 이 두번째 방식이 Nullable의 기본 아이디어이다.

C# 2.0부터 기본 데이터 타입이 NULL값을 가질 수 있도록 Nullable Type을 사용할 수 있게 되었다. int?와 같이 데이터 타입 뒤에 물음표를 붙이면 내부적으로 Nullable<T> 로변환되어 객체화 되며, 해당 데이터 타입은 Null 값을 가질 수 있게된다. 내부적으로는 데이터를 객체의 .Value 멤버를 사용한다. 

C# 에서는 Value Type에도 null을 할당할 수 있는 Nullable 타입을 지원한다. Nullable 타입은 Value 값을 갖고 있으면서 NULL 상태를 체크할 수 있는 기능(HasValue)을 함께 가지고 있는 struct 이다. 따라서 Nullable 타입은 struct(구조체)이므로 Value Type이다.

C#에서 int? 와 같이 해당 Value Type 뒤에 물음표를 붙이면, 해당 정수형 타입이 Nullable 정수형 타입임을 의미한다. 즉, 이 변수에는 NULL을 할당할 수 있다. C#의 이러한 특별한 문법은 .NET의 Nullable<T> 구조체로 컴파일시 변환된다. 즉, int?는 Nullable<int>와 동일하다.

```cs
// Nullable 타입
int? i = null;
i = 101;
            
bool? b = null;

//int? 를 int로 할당
Nullable<int> j = null;
j = 10;
int k = j.Value;
```

#### Nullable<T> 

C#에서 int?, bool?, DateTime? 와 같은 T? 의 표현은 .NET의 Nullable<T>와 같은 표현이며, Nullable<T> 구조체는 값을 가지고 있는지를 체크하는 (즉, missing value가 아닌지를 체크하는) HasValue 속성과 실제 값을 나타내는 Value 속성을 가지고 있다. Nullable 구조체는 타입 캐스팅을 통한 변환이나 암묵적 변환을 통해 (Non-nullable) Value 타입으로 변환된다. 당연한 얘기지만, Value 타입이 아닌 레퍼런스 타입은 Nullable을 쓸 필요가 없는데, 그것은 모든 레퍼런스 타입은 이미 NULL을 허용하기 때문이다.
Nullable 타입이 실무에서 흔히 사용되는 케이스는 DB와 연동되는 Data Layer 클래스들을 들 수 있는데, 예를 들어 SQL 서버 테이블에서 NULL을 허용하는 숫자, 날짜, bool등의 컬럼이 있다면, 이 컬럼 타입은 Nullable 타입으로 변환되어 테이블의 NULL 속성을 표현하게 된다. 아래 예제는 다양한 종류의 Nullable 파라미터를 받아들여 HasValue로 NULL 값을 미리 체크한 후, .Value 속성을 써서 해당 타입의 실제 값을 사용하고 있다.

Nullable 타입과 연관되어 자주 사용되는 C#의 ?? 연산자는 ?? 앞의 파라미터가 NULL인 경우 연산자 뒤의 값을 할당할 때 사용한다.

```cs
double _Sum = 0;
DateTime _Time;
bool? _Selected;

public void CheckInput(int? i, double? d, DateTime? time, bool? selected)
{
    if (i.HasValue && d.HasValue)
        this._Sum = (double)i.Value + (double)d.Value;

    // time값이 있는 체크.
    if (!time.HasValue)
        throw new ArgumentException();
    else
        this._Time = time.Value;

    // 만약 selected가 NULL이면 false를 할당
    this._Selected = selected ?? false;
}
```

#### Nullable 정적 클래스

.NET Framework에 있는 정적(static) 클래스 System.Nullable 은 두개의 Nullable 객체를 비교하거나 (Compare(), Equals() 메서드), 특정 Nullable 타입이 어떤 Value 타입에 기반을 두고 있는지 알아내는 (GetUnderlyingType() 메서드) 기능을 제공하고 있다. 이 정적 클래스는 Nullable<T> 타입을 위한 몇 가지 편리한 정적 메서드들을 제공한다.

```cs
void NullableTest()
{
    int? a = null;
    int? b = 0;            
    int result = Nullable.Compare<int>(a, b);
    Console.WriteLine(result); //결과 -1

    double? c = 0.01;
    double? d = 0.0100;
    bool result2 = Nullable.Equals<double>(c, d);
    Console.WriteLine(result2); //결과 true
}
```

### C# Array

배열은 일련의 동일한 데이타 타입 요소들로 구성된 데이타 집합으로서, 인덱스를 통하여 개개의 배열요소(Element)를 엑세스할 수 있다. C#에서 배열은 Zero-based Array 즉 첫번째 요소가 인덱스 0을 갖는다. 두번째 요소는 인덱스 1, 그 다음 요소들은 인덱스 2, 3, ... 등을 갖는다.

모든 C# 배열은 내부적으로 .NET Framework의 System.Array에서 파생된 것이다. 따라서, System.Array의 메서드, 프로퍼티를 사용할 수 있다.

배열은 레퍼런스(Reference) 타입이기 때문에, 배열을 다른 객체나 메서드에 전달할 때, 직접 모든 배열 데이타를 복사하지 않고, 배열 전체를 가리키는 참조 값(Reference pointer)만을 전달한다. 즉, 전달하는 쪽에서는 단순히 레퍼런스인 배열명을 사용하며, 받는 쪽에서는 아래 예제와 같이 배열 데이타 타입 및 배열 파라미터명을 사용한다.

C# 배열은 1차배열, 2차배열, 3차배열,..., 32차 배열 등 최고 32차 배열을 가질 수 있다. 2차 이상의 다차원 배열은 (1)각 차원별 요소 크기가 고정된 Rectangular 배열과 (2) 각 차원별 크기가 서로 다른 가변배열로 나뉠 수 있다.

다음은 1차 배열과 2차,3차 배열(C-Style의 Rectangular 배열)을 선언하는 예이다. 아래 예제에서 배열 players는 10개의 string 요소를 갖도록 선언되었고, Regions/Depts는 각각 1차,2차 배열이며 초기화 값들을 할당하고 있다. 마지막의 Cubes 는 3차배열을 선언한 예이다.

```cs
// 1차 배열
string[] players = new string[10];
string[] Regions = { "서울", "경기", "부산" };

// 2차 배열 선언 및 초기화
string[,] Depts = {%{"김과장", "경리부"},{"이과장", "총무부"}%};

// 3차 배열 선언
string[,,] Cubes;
```

#### 가변 배열 (Jagged Array)

다차원 배열에서 각 차원별 배열 요소 크기가 동일한 Rectangular 배열은 C#에서 [,] 와 같이 괄호안에 콤마로 분리하여 (C 언어 스타일) 다차원을 표현한다. 하지만 각 차원별 배열 요소 크기가 가변적인 가변 배열(Jagged Array)의 경우 [][] 와 같이 각 차원마다 괄호를 별도로 사용한다 (Java 언어 스타일).

```cs
//Jagged Array (가변 배열)
//1차 배열 크기(3)는 명시해야
int[][] A = new int[3][];

//각 1차 배열 요소당 서로 다른 크기의 배열 할당 가능
A[0] = new int[2];
A[1] = new int[3] { 1, 2, 3 };
A[2] = new int[4] { 1, 2, 3, 4 };

A[0][0] = 1;
A[0][1] = 2;
```

### C# 문자열

문자열(string)은 프로그램에서 가장 많이 쓰이는 데이타 타입 중의 하나이다. C#에서 문자열(string)은 이중부호를 사용하여 표현되며, 단일 문자(char)는 단일부호를 사용하여 표현된다.

C#의 키워드 string은 .NET의 System.String 클래스와 동일하며, 따라서 System.String 클래스의 모든 메서드와 속성(Property)을 사용할 수 있다. 예를 들어 일정 문자열 부분만 뽑아내는 Substring() 메서드, 문자열 길이를 구하는 Length 속성 등을 모두 사용할 수 있다.

C# 문자열은 Immutable 즉 한번 문자열이 설정되면, 다시 변경할 수 없다. (주: 한번 그 값이 설정되면 다시 변경할 수 없는 타입을 Immutable Type이라 부르고, 반대로 값을 계속 변경할 수 있는 것을 Mutable Type이라 부른다) 예를 들어, 문자열 변수 s 가 있을 때, s = "C#"; 이라고 한 후 다시 s = "F#"; 이라고 실행하면, .NET 시스템은 새로운 string 객체를 생성하여 "F#"이라는 데이타로 초기화 한 후 이를 변수명 s 에 할당한다. 즉, 변수 s 는 내부적으로는 전혀 다른 메모리를 갖는 객체를 가리키는 것이다.

```cs
using System;

namespace MySystem
{
   class Program
   {
      static void Main(string[] args)
      {         
         // 문자열(string) 변수
         string s1 = "C#";
         string s2 = "Programming";

         // 문자(char) 변수 
         char c1 = 'A';
         char c2 = 'B';

         // 문자열 결합
         string s3 = s1 + " " + s2;
         Console.WriteLine("String: {0}", s3);

         // 부분문자열 발췌
         string s3substring = s3.Substring(1, 5);
         Console.WriteLine("Substring: {0}", s3substring);
      }
   }
}
```

#### C# StringBuilder 클래스

문자열을 다루는데 중요한 클래스 중의 하나는 System.Text.StringBuilder 클래스이다. String 클래스는 위에서 설명한 대로 Immutable이기 때문에, 문자열 갱신을 많이 하는 프로그램에는 적당하지 않다. 반면 Mutable 타입인 StringBuilder 클래스는 문자열 갱신이 많은 곳에서 자주 사용되는데 이는 이 클래스가 별도 메모리를 생성,소멸하지 않고 일정한 버퍼를 갖고 문자열 갱신을 효율적으로 처리하기 때문이다.

특히 루프 안에서 계속 문자열을 추가 변경하는 코드에서는 string 대신 StringBuilder를 사용해야 한다.

```cs
using System;
using System.Text;

namespace MySystem
{
   class Program
   {
      static void Main(string[] args)
      {                  
         StringBuilder sb = new StringBuilder();
         for (int i = 1; i <= 26; i++)
         {
            sb.Append(i.ToString());
            sb.Append(System.Environment.NewLine);
         }
         string s = sb.ToString();

         Console.WriteLine(s);
      }
   }
}
```

### C# enum (열거형)

C#의 키워드 enum은 열거형 상수(constant)를 표현하기 위한 것으로 이를 이용하면 상수 숫자들을 보다 의미있는 단어들로 표현할 수 있어서 프로그램을 읽기 쉽게 해준다.

enum의 각 요소는 별도의 지정없이는 첫번째 요소가 0, 두번째 요소가 1, 세번째 요소가 2 등과 같이 1씩 증가된 값들을 할당받는다. 물론, 개발자가 임의로 의미있는 번호를 지정해 줄 수도 있다. enum문은 클래스 안이나 네임스페이스 내에서만 선언될 수 있다. 즉, 메서드 안이나 속성 안에서는 선언되지 않는다.

```cs
public enum Category
{
   Cake,
   IceCream,
   Bread
}
```


#### 플래그(flag) enum

enum의 각 멤버들은 각 비트별로 구분되는 값들(예: 1,2,4,8,...)을 갖을 수 있는데, 이렇게 enum 타입이 비트 필드를 갖는다는 것을 표시하기 위해 enum 선언문 바로 위에 [Flags] 라는 Attribute (주: Type 혹은 그 멤버를 선언할 때 그 위에 붙이는 특별한 특성값으로 해당 타입 혹은 멤버가 어떤 특성을 갖고 있는지 나타내게 된다)를 지정할 수 있다.

[Flags] 특성을 갖는 플래그 enum은 OR 연산자를 이용해서 한 enum 변수에 다중값(예: 1+4)을 가질 수 있으며, AND 연산자를 이용하여 enum 변수가 특정 멤버를 포함하고 있는지 체크할 수 있다.

아래 예제는 Border라는 플래그 enum으로 OR 연산을 통해 다중값을 표현하고, AND 연산을 통해 특정멤버를 체크해보는 코드를 보여주고 있다.
또한, 플래그 enum에 대해 .ToString() 메서드를 사용하면 해당 플래그 멤버명들을 문자열로 보여준다는 것이다. [Flags]가 없으면 1+4 즉 5를 출력한다.

```cs
[Flags]
enum Border
{
    None = 0,
    Top = 1,
    Right = 2,
    Bottom = 4,
    Left = 8
}

static void Main(string[] args)
{
    // OR 연산자로 다중 플래그 할당
    Border b = Border.Top | Border.Bottom;

    // & 연산자로 플래그 체크
    if ((b & Border.Top) != 0)
    {
        //HasFlag()이용 플래그 체크
        if (b.HasFlag(Border.Bottom))
        {
            // "Top, Bottom" 출력
            Console.WriteLine(b.ToString());
        }
    }
}
```

### C# 제네릭 (C# Generics)

일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다. 예를 들어, 사칙연산을 하는 클래스 A가 있다고 가정하자. 이 클래스 A에는 int 타입의 필드들이 있고, int 타입을 파라미터로 받아 계산하는 메서드들도 있다. 그러면 이 클래스 A를 double 타입의 데이타를 가지고 사용할 수 있을까? 그렇 수 없다. 왜냐하면 이미 모든 필드 및 파라미터가 int로 설정되어 있기 때문이다.

이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다. 이렇게 정의된 클래스 즉 C# 제네릭 타입을 사용할 때는 클래스명과 함께 구체적인 데이타 타입을 함께 지정해 주게 된다. 이렇게 하면 일부 상이한 데이타 타입 때문에 여러 개의 클래스들을 따로 만들 필요가 없어지게 된다. C# 제네릭은 이렇게 클래스 이외에도 인터페이스나 메서드에도 적용될 수 있다.

요약하면, C# 제네릭은 C++의 템플릿과 비슷한 (주: 내부 아키텍쳐는 상당한 차이점이 있다) 개념으로서 클래스, 인터페이스, 메서드 등에 <T> 같은 타입 파라미터를 붙여 구현한다. 사용시에는 이 타입 파라미터에 특정 타입을 지정하게 되는데, 실행(Runtime)시에 제네릭 타입(Generic Type)으로부터 지정된 타입의 객체(object)를 구체적으로 생성해서 사용하게 된다. 타입 파라미터는 하나 이상 여러 개를 지정할 수도 있다.

```cs
// 어떤 요소 타입도 받아들 일 수 있는
// 스택 클래스를 C# 제네릭을 이용하여 정의
class MyStack<T>
{
    T[] _elements;
    int pos = 0;

    public MyStack()
    {
        _elements = new T[100];
    }

    public void Push(T element)
    {
        _elements[++pos] = element;
    }

    public T Pop()
    {
        return _elements[pos--];
    }
}

// 두 개의 서로 다른 타입을 갖는 스택 객체를 생성
MyStack<int> numberStack = new MyStack<int>();
MyStack<string> nameStack = new MyStack<string>();
```

#### .NET Generic 클래스들

.NET Framework에는 상당히 많은 제네릭 클래스들이 포함되어 있는데, 특히 System.Collections.Generic 네임스페이스에 있는 모든 자료구조 관련 클래스들은 제네릭 타입이다. 흔히 사용하는 List<T>, Dictionary<T>, LinkedList<T> 등의 클래스들은 이 네임스페이스 안에 들어 있다. 아래는 이들을 사용한 한 예이다.

```cs
List<string> nameList = new List<string>();
nameList.Add("홍길동");
nameList.Add("이태백");

Dictionary<string, int> dic = new Dictionary<string, int>();
dic["길동"] = 100;
dic["태백"] = 90;
```

#### 제네릭 타입 제약 (Type Constraint)

C# 제네릭 타입을 선언할 때, 타입 파라미터가 Value Type인지 Reference Type인지, 또는 어떤 특정 Base 클래스로부터 파생된 타입인지, 어떤 인터페이스를 구현한 타입인지 등등을 지정할 수 있는데, 이는 where T : 제약조건 과 같은 식으로 where 뒤에 제약 조건을 붙이면 가능하다. 아래는 다양한 제약을 가한 예제들이다.

```cs
// T는 Value 타입
class MyClass<T> where T : struct 

// T는 Reference 타입
class MyClass<T> where T : class

// T는 디폴트 생성자를 가져야 함
class MyClass<T> where T : new() 

// T는 MyBase의 파생클래스이어야 함
class MyClass<T> where T : MyBase

// T는 IComparable 인터페이스를 가져야 함
class MyClass<T> where T : IComparable

// 좀 더 복잡한 제약들
class EmployeeList<T> where T : Employee,
   IEmployee, IComparable<T>, new()
{
}

// 복수 타입 파라미터 제약
class MyClass<T, U> 
    where T : class 
    where U : struct
{
}
```

### Delegate

C# delegate는 C/C++의 함수 포인터와 비슷한 개념으로 메서드 파라미터와 리턴 타입에 대한 정의를 한 후, 동일한 파라미터와 리턴 타입을 가진 메서드를 서로 호환해서 불러 쓸 수 있는 기능이다.

```cs
delegate int MyDelegate(string s);
void Run(MyDelegate method) { ... }
```

델리게이트 정의에서 중요한 것은 입력 파리미터들과 리턴 타입이다. 만약 어떤 메서드가 이러한 델리게이트 메서드 원형(Prototype)과 일치한다면, 즉 입력 파리미터 타입 및 갯수, 리턴 타입이 동일하다면 그 메서드는 해당 델리게이트에서 사용될 수 있다.

델리게이트 정의는 마치 하나의 함수(메서드)를 정의하는 Prototype 선언식처럼 보이는데, 사실 내부적으로 이 선언식은 컴파일러에 의해 특별한 클래스로 변환된다.

> (주: C# 컴파일러는 위의 delegate 정의를 읽어, System.MulticastDelegate 클래스로부터 파생된 MyDelegate 클래스를 생성하게 된다. 따라서 delegate는 메서드를 전달하기 위해 메서드 메타정보를 내부에 갖고 있는 특별한 종류의 Wrapper 클래스라 볼 수 있다. 그러면, 델리게이트 생성시 C# delegate 키워드 말고 직접 System.MulticastDelegate 클래스로부터 파생된 클래스를 만들 수 있을까? 이는 불가능하다. System.MulticastDelegate 클래스는 특별한 .NET 클래스로 Base클래스로 사용될 수 없다.)


> 이렇게 C# delegate 식을 클래스가 아닌 함수 선언식처럼 정의하게 한 것은 내부의 복잡한 설계를 숨기고 '메서드를 전달하는 본연의 의도'를 더 직관적으로 표현하기 위한 것으로 볼 수 있다.
> (C# delegate는 내부적으로 .NET Delegate / MulticastDelegate 클래스를 사용한다. 따라서 이 클래스가 지원하는 속성 (예: .Method - 함수 Prototype을 보여줌)과 메서드 (예: GetInvokcationList())를 모두 사용할 수 있다)
> 델리게이트가 이렇게 정의된 후에는 클래스 객체를 생성한 것과 비슷한 방식으로 new를 써서 델리게이트 객체를 생성한다.
> (주: delegate는 결국 클래스이므로 클래스 객체 생성과 같은 방식을 사용한다)
> 델리게이트를 다른 메서드에 전달하는 방식은 델리게이트 객체를 메서드 호출 파라미터에 넣으면 된다. 이는 메서드를, 좀 더 정확히는 그 메서드 정보를 갖는 Wrapper 클래스의 객체를, 다른 메서드의 입력 파라미터로 전달하는 것이 된다.
> 전달된 델리게이트로부터 실제 메서드를 호출하는 것은 어떻게 하는가? 이는 델리게이트 객체의 .Invoke() 메서드나 .BeginInvoke() 메서드를 써서 호출한다. 예를 들어, m 이라는 델리게이트 객체를 전달 받았을 경우, 아래와 같이 Invoke() 메서드를 호출한다. 만약 메서드에 입력파라미터가 있을 경우, 이를 Invoke() 안에 추가한다.
> 또 다른 메서드 호출방법으로 C# 프로그래머들이 더 애용하는 방식은, .Invoke 메서드명을 생략하고 다음과 같이 직접 함수처럼 사용하는 방법이다. 이 방식은 마치 메서드를 직접 호출하는 느낌을 주므로 더 직관적이다.

> ```cs
> // int StringToInt(string s) { ... }
> 
> MyDelegate m = new MyDelegate(StringToInt);
> Run(m);
> 
> ...
> i = m.Invoke("123");
> i = m("123");
> ```

```cs
class Program
{
    static void Main(string[] args)
    {
        new Program().Test();
    }

    // 델리게이트 정의
    delegate int MyDelegate(string s);

    void Test()
    {
        //델리게이트 객체 생성
        MyDelegate m = new MyDelegate(StringToInt);

        //델리게이트 객체를 메서드로 전달
        Run(m);
    }

    // 델리게이트 대상이 되는 어떤 메서드
    int StringToInt(string s)
    {
        return int.Parse(s);
    }

    // 델리게이트를 전달 받는 메서드
    void Run(MyDelegate m)
    {
        // 델리게이트로부터 메서드 실행
        int i = m("123");

        Console.WriteLine(i);
    }
}
```

#### Delegate를 이용한 Sorting 예제

아래 예제는 올림차순으로 비교하는 함수(AscendingCompare) 와 내림차순으로 비교하는 함수(DescendingCompare)를 delegate로 전달하여, 하나의 Sort() 메서드에서 전달된 delegate 비교함수에 따라 여러 방식으로 소트가 가능하다는 것을 보여주는 예이다.

```cs
class MySort
{
    // 델리게이트 CompareDelegate 선언
    public delegate int CompareDelegate(int i1, int i2);

    public static void Sort(int[] arr, CompareDelegate comp)
    {
        if (arr.Length < 2) return;
        Console.WriteLine("함수 Prototype: " + comp.Method);

        int ret;
        for (int i = 0; i < arr.Length - 1; i++)
        {
            for (int j = i+1; j < arr.Length; j++)
            {
                ret = comp(arr[i], arr[j]);
                if (ret == -1)
                {
                    // 교환
                    int tmp = arr[j];
                    arr[j] = arr[i];
                    arr[i] = tmp;
                }
            }
        }
        Display(arr);
    }
    static void Display(int[] arr)
    {
        foreach (var i in arr) Console.Write(i + " ");
        Console.WriteLine();
    }
}

class Program
{
    static void Main(string[] args)
    {
        (new Program()).Run();
    }

    void Run()
    {
        int[] a = { 5, 53, 3, 7, 1 };
        
        // 올림차순으로 소트
        MySort.CompareDelegate compDelegate = AscendingCompare;
        MySort.Sort(a, compDelegate);

        // 내림차순으로 소트
        compDelegate = DescendingCompare;
        MySort.Sort(a, compDelegate);            
    }

    // CompareDelegate 델리게이트와 동일한 Prototype
    int AscendingCompare(int i1, int i2)
    {
        if (i1 == i2) return 0;
        return (i2 - i1) > 0 ? 1 : -1;
    }

    // CompareDelegate 델리게이트와 동일한 Prototype
    int DescendingCompare(int i1, int i2)
    {
        if (i1 == i2) return 0;
        return (i1 - i2) > 0 ? 1 : -1;
    }
}
```

#### Multicast Delegate

C# delegate는 여러 개의 메서드들을 할당하는 것이 가능하다. C# 연산자 += 을 사용하면 메서드를 계속 delegate 에 추가하게 되는데, 내부적으로는 .NET MulticastDelegate 클래스에서 이 메서드들의 리스트(이를 InvocationList 라고 한다)를 관리하게 된다.

복수개의 메서드들이 한 delegate에 할당되면, 이 delegate가 실행될 때, InvocationList로부터 순서대로 메서드를 하나씩 가져와 실행한다. 아래 예제는 복수 개의 메서드를 한 delegate에 계속 추가하는 예이다.

```cs
class Program
{
   static MyArea area;

   static void Main(string[] args)
   {
      area = new MyArea();

      //복수개의 메서드를 delegate에 할당
      area.MyClick += Area_Click;
      area.MyClick += AfterClick;

      area.ShowDialog();
   }

   static void Area_Click(object sender)
   {
      area.Text += " MyArea 클릭! ";
   }

   static void AfterClick(object sender)
   {
      area.Text += " AfterClick 클릭! ";
   }
}
```

#### Delegate와 Event의 차이

모든 이벤트(event)는 특수한 형태의 delegate이다. C#의 delegate 기능은 경우에 따라 잘못 사용될 소지가 있다. 예를 들어, 우리가 Button 컨트롤을 개발해 판매한다고 하자. 이 컨트롤은 delegate 필드를 가지고 있고, 버튼 클릭시 InvocationList에 있는 모든 메서드들을 차례로 실행하도록 하였다. 그런데, Button 컨트롤을 구입한 개발자가 한 컴포넌트에서 추가 연산(+=)을 사용 하지 않고 실수로 할당 연산자(=)를 사용하였다고 가정하자. 이 할당연산은 기존에 가입된 모든 메서드 리스트를 지워버리고 마지막에 할당한 메서드 한개만 InvocationList에 넣게 할 것이다. 즉, 누구든 할당 연산자를 한번 사용하면 기존에 가입받은 모든 메서드 호출요구를 삭제하는 문제가 발생한다.

이러한 문제점과 더불어 또다른 중요한 문제점은 delegate는 해당 클래스 내부에서 뿐만 아니라, 외부에서도 누구라도 메서드를 호출하듯 (접근 제한이 없다면) 해당 delegate를 호출할 수 있다는 점이다. 아래 예제는 할당연산자를 사용해서 기존 delegate를 덮어쓰는 예와 delegate를 외부에서 호출하는 예를 보여준다.

```cs
static void Main(string[] args)
{
   area = new MyArea();
         
   area.MyClick += Area_Click;
   area.MyClick += AfterClick;

   area.Show();

   // 덮어쓰기: MyClick은 Area_Click메서드만 갖는다
   area.MyClick = Area_Click;

   // C# delegate는 클래스 외부에서 호출할 수 있다.
   // C# event는 불가
   area.MyClick(null);
}
```

위와 같은 delegate의 문제점들을 극복하기 위해서 특별한 형태의 delegate 로서의 C# event를 사용할 수 있다. C# event는 할당연산자( = )를 사용할 수 없으며, 오직 이벤트 핸들러 추가(+= 연산자, Subscribe) 혹은 기존 이벤트 핸들러 삭제 (-= 연산자, Unsubscribe)만을 할 수 있다. 또한 delegate 와는 달리 해당 클래스 외부에서는 직접 이벤트를 호출할 수 없다.

```cs
using System.Windows.Forms;
namespace MySystem
{
   class MyArea : Form
   {
      public MyArea()
      {
         // 이 부분은 당분간 무시. (무명메서드 참조)
         // 예제를 테스트하기 위한 용도임.
         this.MouseClick += delegate { MyAreaClicked(); };
      }

      public delegate void ClickEvent(object sender);

      // event 필드
      public event ClickEvent MyClick;

      // 예제를 단순화 하기 위해
      // MyArea가 클릭되면 아래 함수가 호출된다고 가정
      void MyAreaClicked()
      {
         if (MyClick != null)
         {
            MyClick(this);
         }
      }
   }

   class Program
   {
      static MyArea area;

      static void Main(string[] args)
      {
         area = new MyArea();
         
         // 이벤트 가입
         area.MyClick += Area_Click;
         area.MyClick += AfterClick;

         // 이벤트 탈퇴
         area.MyClick -= Area_Click;

         // Error: 이벤트 직접호출 불가
         //area.MyClick(this);

         area.ShowDialog();
      }

      static void Area_Click(object sender)
      {
         area.Text += " MyArea 클릭! ";      
      }

      static void AfterClick(object sender)
      {
         area.Text += " AfterClick 클릭! ";      
      }
   }
}
```

#### Delegate와 Function Pointer(C언어)의 차이

C# delegate는 메서드의 레퍼런스를 갖고 있다는 점에서 C의 함수 포인터(function pointer)와 닮았다. 하지만 C# delegate는 몇 가지 측면에서 C의 함수 포인터와 다르다.

첫번째로 클래스의 개념이 없는 C에서의 함수 포인터는 말 그대로 외부의 어떤 함수에 대한 주소값만을 갖는다. 반면 C#의 delegate는 클래스 객체의 인스턴스 메서드에 대한 레퍼런스를 갖기 위해 그 C# 객체의 주소(객체 레퍼런스)와 메서드 주소를 함께 가지고 있다. (주: 물론 Static 메서드의 경우에는 객체의 레퍼런스값이 null 이 된다) C# delegate는 델리게이트 Type을 정의하는 것으로 이 Type으로부터 델리게이트 객체를 생성할 때, 이 객체가 메서드 정보와 객체 정보를 가진다.
클래스를 사용하는 C++에는 Pointer to member function이 있는데, 이는 한 클래스의 멤버 함수에 대한 포인터로서 '객체'에 대한 컨텍스트를 가지고 있다는 점에서 C#의 delegate와 비슷하다. 단, C#의 delegate는 메서드 Prototype이 같다면 어느 클래스의 메서드도 쉽게 할당할 수 있는데 반해, C++의 Pointer to member는 함수 포인터 선언시 특정 클래스를 지정해주기 때문에 한 클래스에 대해서만 사용할 수 있다.

두번째로 C의 함수 포인터는 하나의 함수 포인터를 갖는데 반해, C# delegate는 하나 이상의 메서드 레퍼런스들을 가질 수 있어서 Multicast가 가능하다.

또한 C의 함수포인터는 Type Safety를 완전히 보장하지 않는 반면, C#의 delegate는 엄격하게 Type Safety를 보장한다.

```cpp
// C 함수 포인터 예제

void myfunc(int x) 
{
    printf( "%d\n", x );
}

void main()
{
    // 함수포인터 f 정의
    void (*f)(int);    

    // 함수포인터에 함수 지정
    f = &myfunc;

    // 함수 실행
    f(2);
}


// C++ Pointer to member 예제
#include <iostream>
#include <string>
class Cls
{
public:
    // 클래스 메서드 멤버
    void myfunc(std::string str)
    {
        std::cout << str << std::endl;    
    }
};
 
void main()
{
    // Pointer to member function 정의
    void (Cls::*fp)(std::string);
  
    // Pointer to member 지정
    fp = &Cls::myfunc;

    // Cls 객체 생성 및 객체 포인터 지정
    Cls obj;
    Cls* pObj = &obj;
  
    // Cls 객체에서 함수포인터 사용
    (pObj->*fp)("hello");
}
```


### 연산자

C#은 여타 다른 프로그래밍 언어와 같게 산술, 할당, 증감, 논리, 비교, 비트, 쉬프트 연산자를 지원하고, 이외에 조건 연산자를 지원한다.

- 산술 연산자
    - +, -, *, /, %

```cs
int a = (x + y - z) * (b / c) % d;
```

- 할당 연산자
	- =, +=, -=, *=, /=, %=	

```cs
int a = 100;
sum += a;
[설명] sum += a 는 sum = sum + a 를 축약한 표현이다.
```

- 증감 연산자
	- ++, --	

```cs
int i = 1;
i++;
[설명] i++ 는 i = i + 1 를 축약한 표현이다.
```

- 논리 연산자
	- && (And), || (Or), ! (Not)	

```cs
if ((a > 1 && b < 0) || c == 1 || !d)
```

- 관계/비교 연산자	
    - <, >, ==, !=, >=, <=	

```cs
if (a <= b)
```

- 비트 연산자	
    - & (AND), | (OR), ^ (XOR)	

```cs    
byte a=7;
byte b=(a & 3) | 4;
[설명] 비트 연산에서 & 는 둘이 1인 경우만 1이 되고 (예: 1 & 1 = 1), | 는 둘 중에 하나라도 1인 경우 1이 되며, ^ 는 둘 중에 하나만 1 인 경우 1이 된다.
```

- Shift 연산자
	- >>, <<	

```cs
int i=2;
i = i << 5;
[설명] i의 값을 왼쪽으로 5 비트 이동한다. 결과값은 2의 6승 즉 64가 된다.
```

- 조건 연산자	
    - ?, ?? (C# 3.0 이상만 지원)

```cs
int val = (a > b) ? a : b;
[설명] a가 b보다 크면 val에 a 값을 대입하고, 같거나 작으면 b 값을 대입한다
string s = str ?? "(널)";
[설명] 변수 str가 null 이면 "(널)" 이라는 문자열을 s 에 대입한다. null 이 아니면 str의 값을 s 에 대입.
```

#### ?? 연산자

?? 연산자는 Null-coalescing operator라고 불리우는 특별한 연산자로서 C# 3.0 이상에서 지원하는 연산자이다. ?? 연산자는 ?? 왼쪽 피연산자의 값이 NULL인 경우 ?? 뒤의 피연산자 값을 리턴하고, 아니면 그냥 ?? 앞의 피연산자 값을 리턴한다. ?? 연산자는 왼쪽 피연산자가 NULL이 허용되는 데이타 타입인 경우에만 사용된다. 예를 들어, int 타입은 NULL을 가질 수 없으므로 허용되지 않지만, Nullable<int> 즉 int? 타입은 허용된다.

```cs
int? i = null;
i = i ?? 0;

string s = null;
s = s ?? string.Empty;
```

### 조건문

#### if 조건문

if 문은 조건식이 참, 거짓인지에 따라 서로 다른 블럭의 코드를 실행하게 한다. 예를 들면, if (조건식) { 블럭1 } else { 블럭2 } 문장의 경우, 조건식이 참이면 블럭1을 실행하고, 거짓이면 블럭2를 실행한다.

#### C# switch 조건문

switch 문은 조건값이 여러 값들을 가질 경우 각 case 별 다른 문장들을 실행할 때 사용된다. 각각의 경우에 해당하는 값을 case 문 뒤에 지정하며, 어떤 경우에도 속하지 않는 경우는 default 문을 사용해 지정한다. 각 case문 내에서 break 문을 사용하게 되면 해당 case 블럭의 문장들을 실행하고 switch 문을 빠져 나오게 된다.

```cs
using System;

namespace MySystem
{
    class Program
    {
        static bool verbose = false;
        static bool continueOnError = false;
        static bool logging = false;

        static void Main(string[] args)
        {            
            if (args.Length != 1)
            {
                Console.WriteLine("Usage: MyApp.exe option");
                return;
            }

            string option = args[0];
            switch (option.ToLower())
            {
                case "/v":
                case "/verbose":
                    verbose = true;                    
                    break;
                case "/c":
                    continueOnError = true;
                    break;
                case "/l":
                    logging = true;
                    break;
                default:
                    Console.WriteLine("Unknown argument: {0}", option);
                    break;
            }
        }
    }
}
```

### 반복문

#### C# for 반복 구문

C# for 문은 루프 안에 있는 문장들을 반복적으로 실행할 때 사용한다. for 루프는 일반적으로 카운터 변수를 이용해 일정 범위 동안 for 루프 안의 블럭을 실행한다.

```cs
class Program
{
    static void Main(string[] args)
    {
        // for 루프
        for (int i = 0; i < 10; i++)
        {
           Console.WriteLine("Loop {0}", i);
        }
    }
```

#### C# foreach 반복 구문

C# foreach 문은 배열이나 컬렉션에 주로 사용하는데, 컬렉션의 각 요소를 하나씩 꺼내와서 foreach 루프 내의 블럭을 실행할 때 사용된다. 다음 예제는 문자열 배열을 foreach를 사용하여 각 문자열 요소를 하나씩 출력하는 코드이다.

```cs
static void Main(string[] args)
{
    string[] array = new string[] { "AB", "CD", "EF" };

    // foreach 루프
    foreach (string s in array)
    {
       Console.WriteLine(s);
    }
}
```

#### C# while 반복 구문

C# while 문은 while 조건식이 true인 동안 계속 while 블럭을 실행할 때 사용한다. 다음 예제는 while문을 사용하여 1부터 10까지 숫자를 콘솔에 출력하는 코드이다. 아래에서 i가 11이 되면 while 조건식이 false가 되어 while 루프를 빠져나오게 된다.

```cs
static void Main(string[] args)
{
    int i=1;

    // while 루프
    while (i <= 10)
    {
       Console.WriteLine(i);
       i++;
    }
}
```

#### C# do while 반복 구문

do ~ while은 위의 while문과 거의 비슷하나, 마지막 while 조건식까지 가기 전에 do ~ while 사이의 블럭을 미리 한번 실행한다는 점에서 차이가 있다.

```cs
static void Main(string[] args)
{
    int i=1;

    // do ~ while 루프
    do
    {
       Console.WriteLine(i);
       i++;
    } while (i < 10);
}
```

### 반복자(Iterator, Enumerator)

C#의 yield 키워드는 호출자(Caller)에게 컬렉션 데이타를 하나씩 리턴할 때 사용한다. 흔히 Enumerator(Iterator)라고 불리우는 이러한 기능은 집합적인 데이타셋으로부터 데이타를 하나씩 호출자에게 보내주는 역할을 한다.

yield는 yield return 또는 yield break의 2가지 방식으로 사용되는데, (1) yield return은 컬렉션 데이타를 하나씩 리턴하는데 사용되고, (2) yield break는 리턴을 중지하고 Iteration 루프를 빠져 나올 때 사용한다.

yield 의 간단한 예제로 아래 코드를 살펴보자. GetNumber() 라는 메서드는 3개의 yield return 문을 가지고 있다. 만약 외부에서 이 GetNumber()를 호출하게 되면, 첫번째 호출시에는 첫번째 yield return 10 을 실행하여 10을 리턴하게 되고, 두번째로 호출되면 yield return 20 이 실행되어 20을 리턴하게 된다. 이러한 방식으로 GetNumber()는 한꺼번에 10,20,30을 모두 리턴하는 것이 아니라, 한번 호출시마다 다음 yield return 문의 값을 리턴하는 것이다.

```cs
using System;
using System.Collections.Generic;

class Program
{
    static IEnumerable<int> GetNumber()
    {
        yield return 10;  // 첫번째 루프에서 리턴되는 값
        yield return 20;  // 두번째 루프에서 리턴되는 값
        yield return 30;  // 세번째 루프에서 리턴되는 값
    }

    static void Main(string[] args)
    {
        foreach (int num in GetNumber())
        {
            Console.WriteLine(num);
        }             
    }
}
```

#### C# yield와 Enumerator

C#에서 yield 가 자주 사용되는 곳은 집합적 데이타를 가지고 있는 컬렉션 클래스이다. 일반적으로 컬렉션 클래스는 데이타 요소를 하나 하나 사용하기 위해 흔히 Enumerator(Iterator) 를 구현하는 경우가 많은데, Enumerator를 구현하는 한 방법으로 yield 를 사용할 수 있다.

(참고: 인터페이스에 대한 설명이 차후 아티클에 나오지만, 여기서는 관련된 사항을 참고로 적어둔다. Enumerator는 데이타 요소를 하나씩 리턴하는 기능을 하는 것으로 C#/.NET에서 Enumerator는 IEnumerator 라는 인터페이스를 구현해야 한다. IEnumerator 인터페이스는 Current (속성), MoveNext() (메서드), Reset() (메서드) 등 3개의 멤버로 이루어져 있는데, Enumerator가 되기 위해서는 Current와 MoveNext() 를 반드시 구현해야 한다. 일반적으로 컬렉션 클래스와 별도로 Enumerator를 구현할 수 있고, 이를 컬렉션과 동일한 클래스에서 구현할 수도 있다. 컬렉션 클래스와 같이 Enumeration이 가능한 클래스를 Enumerable 클래스라 부르는데, C#/.NET에서 Enumerable 클래스는 IEnumerable 인터페이스를 구현해야 한다. IEnumerable 인터페이스는 GetEnumerator() 라는 하나의 메서드를 가지고 있는데 GetEnumerator()는 IEnumerator를 구현한 객체를 리턴한다)

컬렉션 타입 혹은 Enumerable 클래스에서 GetEnumerator() 메서드를 구현하는 한 방법으로 yield 를 사용할 수 있다. 즉, GetEnumerator() 메서드에서 yield return를 사용하여 컬렉션 데이타를 순차적으로 하나씩 넘겨주는 코드를 구현하고, 리턴타입으로 IEnumerator 인터페이스를 리턴할 수 있다. C#에서 Iterator 방식으로 yield 를 사용하면, 명시적으로 별도의 Enumerator 클래스를 작성할 필요가 없다.

아래의 예제는 MyList라는 컬렉션 타입에 있는 데이타를 하나씩 리턴하는 GetEnumerator() 메서드의 샘플코드이다. 예제의 GetEnumerator() 메서드는 데이타를 하나씩 리턴하기 위해 yield return문을 while 루프 안에서 사용하고 있다. 클래스 안의 샘플 data는 1부터 5까지 숫자인데, 외부 호출자가 순차적으로 호출하면 yield return에서 하나씩 리턴한다. 예를 들어, 처음에는 1을 리턴하고, 다음에는 2를, 그 다음에는 3을 리턴한다

호출자(Caller)가 이 메서드를 사용하는 방법은
(1) foreach 문을 사용하여 C#에서 자동으로 Iterator 루프 처리를 하게 하는 방법과
(2) GetEnumerator()로부터 IEnumerator 인터페이스를 얻어 MoveNext() 메서드와 Current 속성을 사용하여 개발자가 직접 수동으로 요소를 하나씩 사용하는 방법이 있다. 일반적으로 그 편리성 때문에 foreach 문을 사용하는 방식을 사용한다.

아래 예제의 하단은 foreach문을 사용하여 Enumeration을 하는 방법과 IEnumerator의 멤버를 써서 수동으로 Enumeration을 하는 방법을 예시하고 있다.

### 예외 처리(Exception)

C#을 포함한 모든 .NET 프로그래밍 언어는 .NET Framework의 Exception 메카니즘에 따라 Exception을 처리한다. .NET의 System.Exception은 모든 Exception의 Base 클래스이며, 예외 처리는 이 Exception 객체를 기본으로 처리하게 된다.

만약 Exception이 발생하였는데 이를 프로그램 내에서 처리하지 않으면 (이를 Unhandled Exception이라 부른다) 프로그램은 Crash하여 종료하게 된다.

C#에서는 try, catch, finally라는 키워드를 사용하여 Exception을 핸들링하게 되며, 또한 throw라는 C# 키워드를 통해 Exception을 만들어 던지거나 혹은 기존 Exception을 다시 던질 수 있다.

```cs
try
{
   // 실행하고자 하는 문장들
   DoSomething();
}
catch (Exception ex)
{
   // 에러 처리/로깅 등
   Log(ex);
   throw;
}
```

#### C# try-catch-finally

try 블럭은 실제 실행하고 싶은 프로그램 명령문들을 갖는 블럭이다. 만약 여기서 어떤 에러가 발생하면, 이는 catch 문에서 잡히게 된다. catch문은 모든 Exception을 일괄적으로 잡거나 혹은 특정 Exception을 선별하여 잡을 수 있다.

모든 Exception을 잡고 싶을 때는 catch { ... } 와 같이 하거나 catch (Exception ex) { ... }처럼 모든 Exception의 베이스 클래스인 System.Exception를 잡으면 된다.
특정 Exception을 잡기 위해서는 해당 Exception Type을 catch하면 된다. 즉, Argument와 관련된 Exception을 잡고 싶으면, catch (ArgumentException ex) { ... } 와 같이 잡게된다.

catch 블럭은 하나 혹은 여러 개 일 수 있다. 여러 catch를 사용하는 이유는 각 Exception 유형에 따라 서로 다른 에러 핸들링을 하기 위함이다.

finally는 Exception이 발생했던 발생하지 않았던 상관없이 마지막에 반드시 실행되는 블럭이다. 예를 들어, try 블럭에서 SQL Connection객체를 만든 경우, finally 블럭에서 Connection 객체의 Close() 메서드를 호출하면, 에러 발생 여부와 상관없이 항상 Connection객체가 닫히게 된다.

```cs
try
{
   //실행 문장들
}
catch (ArgumentException ex)
{
   // Argument 예외처리
}
catch (AccessViolationException ex)
{
   // AccessViolation 예외처리
}
finally
{
   // 마지막으로 실행하는 문장들
}
```

#### C# throw

try 블럭에서 Exception이 발생하였는데 이를 catch 문에서 잡었다면, Exception은 이미 처리된 것으로 간주된다. 때때로 catch문에서 기존의 Exception을 다시 상위 호출자로 보내고 싶을 때가 있는데, 이때 throw 를 사용한다.

throw 문은 크게 3가지로 구별될 수 있다. 즉, (1) throw 문 다음에 catch에서 전달받은 Exception 객체를 쓰는 경우, (2) throw 문 다음에 새 Exception 객체를 생성해서 전달하는 경우, (3) throw 문 다음에 아무것도 없는 경우 등이 있다.

(1) throw 문 다음에 catch에서 전달받은 Exception 객체를 쓰는 경우
이는 throw ex; 와 같이 catch (Exception ex) 에서 전달받은 아규먼트 ex 를 사용하는 경우이다. 이러한 throw 방식은 ex 에 담긴 예외 정보를 보전하지만, Stack Trace 정보를 다시 리셋하기 때문에 throw문 이전의 콜스택(Call Stack) 정보를 유실하게 된다. 따라서, 일반적으로 이러한 방식은 사용하지 않는 것이 좋다.

(2) throw 문 다음에 새 Exception 객체를 생성해서 전달하는 경우
새로운 Exception 객체를 만들어 던지기 위해서는 throw new MyException();와 같이 C#의 new를 사용하여 새로운 Exception 객체를 만든 후, 이 객체를 throw 하면 된다. 이는 catch 에서 잡은 Exception을 Wrapping 하여 새로운 Exception을 전달할 때 사용하는데, 잘못 사용하면(InnerException을 포함하지 않으면) 기존 Exception 정보를 잃을 수 있다.
따라서, 이러한 방식을 사용하여 새로운 Exception 객체를 만들 때는 catch 에서 얻은 Exception 객체를 새 객체의 InnerException에 포함시켜 에러 정보를 보전하는 것이 좋다. 예를 들어, throw new MyException(msg, ex); 와 같이 catch에서 전달받은 ex를 InnerException으로 전달하는 것이 좋다. InnerException의 StackTrace 속성은 어느 라인에서 에러가 발생했는지를 알려주는데, 이는 에러가 다른 메서드에서 발생했을 때는 물론 동일 메서드에서 발생했다 하더라도 정확히 어떤 라인에서 에러가 발생했는지를 알게 해 준다.

(3) throw 문 다음에 아무것도 없는 경우
throw; 와 같이 뒤에 어떠한 Exception 객체 없이 그냥 throw문만을 사용할 수 있는데, 이는 catch문에서 잡힌 Exception을 그대로 상위 호출 함수에게 전달하는 일(rethrow)을 한다. 즉, 에러를 발생시킨 콜스택 정보를 그대로 상위 호출 함수에 전달하려면 이렇게 throw; 를 호출하면 된다. 한가지 주목할 점은, throw; 는 에러가 다른 메서드에서 발생했을 때는 그 에러가 발생한 다른 메서드의 위치를 포함하지만, 만약 throw문과 동일한 메서드에서 에러가 발생했다면 동일 메서드의 어느 라인에서 에러가 발생했는지는 포함하지 않는다.

아래 예제는 IndexOutOfRangeException이 발생한 경우 MyException이라는 사용자 정의 Exception객체를 만들어 던지게 하는데, catch에서 잡은 ex 객체를 MyException의 InnerException에 포함시키고 있다. FileNotFoundException이 발생한 경우는 throw ex 와 같이 호출하고 있는데, 이는 throw ex 까지의 이전 콜스택을 제거하기 때문에 throw ex 이후부터의 콜스택 정보만을 전달하게 된다. 마지막으로 그 외의 모든 Exception의 경우는 발생한 Exception을 그대로 상위 호출 함수에게 전달하기 위해 throw; 문을 사용하고 있다.

```cs
try
{
    // 실행 문장들
    Step1();
    Step2();
    Step3();
}
catch(IndexOutOfRangeException ex)
{
    // 새로운 Exception 생성하여 throw
    throw new MyException("Invalid index", ex);
}
catch(FileNotFoundException ex)
{    
    bool success = Log(ex);
    if (!success)
    {
        // 기존 Exception을 throw
        throw ex;
    }
}
catch(Exception ex)
{    
    Log(ex);
    // 발생된 Exception을 그대로 호출자에 전달
    throw;
}
```

#### C# 예외 처리 예제

아래 예제는 SQL Server에 연결하여 데이타베이스 내의 테이블,뷰 등의 SQL Objects 수를 가져온 후 이를 화면에 뿌리는 코드이다.

만약 SQLException 타입의 에러가 발생하면 catch 블럭에서 잡아서 에러 메시지만 콘솔에 표시하고 Exception을 삼키게 된다. 마지막의 finally 블럭은 SqlConnection의 Close() 메서드를 실행하여 Connection을 닫는다. 물론 에러가 발생하지 않더라도 finally 블럭은 실행되며, 따라서 SQL Connection은 항상 닫히게 된다.

```cs
string connStr = "Data Source=(local);Integrated Security=true;";
string sql = "SELECT COUNT(1) FROM sys.objects";
SqlConnection conn = null; 
try
{
    conn = new SqlConnection(connStr);
    conn.Open();
    SqlCommand cmd = new SqlCommand(sql, conn);
    object count = cmd.ExecuteScalar();
    Console.WriteLine(count);                
}
catch (SqlException ex)
{
    Console.WriteLine(ex.Message);
}
finally
{
    if (conn != null && 
        conn.State == System.Data.ConnectionState.Open)
    {
        conn.Close();
    }
}
```

### struct 구조체

C# struct는 구조체를 생성하고 Value Type을 정의하기 위해 사용된다. 많은 경우 C#에서 클래스를 사용하지만, 경우에 따라 클래스보다 상대적으로 가벼운 오버헤드를 지닌 구조체가 필요할 수 있다. C#의 구조체는 클래스와 같이 메서드, 프로퍼티 등 거의 비슷한 구조를 가지고 있지만, 상속은 할 수 없다. 하지만 C# 구조체가 상속(inheritance)은 할 수는 없어도, 클래스와 마찬가지로 인터페이스(interface)를 구현할 수는 있다. (참조: struct 사용시 주의)

```cs
using System;

namespace MySystem
{
   class Program
   {
      // 구조체 정의
      struct MyPoint
      {
         public int X;
         public int Y;

         public MyPoint(int x, int y)
         {
            this.X = x;
            this.Y = y;
         }

         public override string ToString()
         {
            return string.Format("({0}, {1})", X, Y);
         }
      }

      static void Main(string[] args)
      {
         // 구조체 사용
         MyPoint pt = new MyPoint(10, 12);
         Console.WriteLine(pt.ToString());
      }
   }
}
```


### Class (클래스)

C# class 키워드는 Reference Type을 정의하는데 사용된다. 클래스는 메서드 (Method), 속성 (Property), 필드 (Field), 이벤트 (Event) 등을 멤버로 포함하는 소프트웨어 단위로서 보통 이 클래스 정의로부터 객체 (Object)를 생성해서 사용하게 된다. 클래스를 정의할 때 중요한 멤버는 공용(public) 메서드와 속성인데, 이 public 멤버들은 외부 객체와의 상호작용을 위해 사용되어 진다.

- 메서드 (Method): 클래스에서 실제 행동을 일으키는 코드 블럭. 대개 동사 혹은 동사+명사 식으로 메서드명을 정함. 예) Calculate(), DeleteData()
- 속성 (Property): 클래스의 내부 데이타를 외부에서 사용할 수 있게 하거나, 외부에서 클래스 내부의 데이타를 간단하게 설정할 때 사용한다.
- 필드 (Field): 클래스의 내부 데이타는 필드에 저장하게 되며, 필드들은 클래스 객체의 상태를 유지하는데 이용된다. 클래스는 동일하더라도 클래스로부터 생성된 여러 객체들은 다른 필드값을 가짐에 따라 서로 다른 객체 상태를 갖게 된다. 필드는 접근제한자(Access Modifier)에 따라 외부 객체 혹은 상속 객체에서 보여질 수 있다. (public 필드를 만들어 문법적으로 필드를 외부에 노출할 수는 있지만, 이는 객체 지향 프로그래밍 방식에 어긋난다. 이 경우 주로 private 필드를 만들고 public 프로퍼티를 이용해 필드값을 외부에 전달하는 방식을 사용한다)
- 이벤트 (Event): 이벤트는 객체 내부의 특정 상태를, 혹은 어떤 일이 있어났다는 이벤트를 외부로 전달하는데 이용된다. 예를 들어 Button 클래스의 경우 버튼이 클릭되면, 버튼클릭 이벤트에 가입한 모든 외부 객체들에게 그 사실(이벤트)을 통보하게 된다.

#### 클래스 정의

클래스 정의는 class 라는 C# 키워드를 사용해서 정의한다. class 키워드 뒤에 클래스명을 써 주고, 클래스 블럭 안에 필드, 메서드, 속성, 이벤트 등을 정의해 준다. 클래스 각 멤버들은 public, protected, private 등의 접근제한자(Access Modifier)에 따라 외부 객체로부터 접근이 허용될 수도 있고 제한될 수도 있다.

```cs
public class MyCustomer
{
    // 필드
    private string name;
    private int age;

    // 이벤트 
    public event EventHandler NameChanged;

    // 생성자 (Constructor)
    public MyCustomer()
    {
        name = string.Empty;
        age = -1;
    }

    // 속성
    public string Name
    {
        get { return this.name; }
        set 
        {
            if (this.name != value)
            {
                this.name = value;
                if (NameChanged != null)
                {
                    NameChanged(this, EventArgs.Empty);
                }
            }                
        }
    }
    public int Age
    {
        get { return this.age; }
        set { this.age = value; }
    }

    // 메서드
    public string GetCustomerData()
    {
        string data = string.Format("Name: {0} (Age: {1})", 
                    this.Name, this.Age);
        return data;
    }
}
```

#### 클래스 상속(Class Inheritance)

C#에서 부모 클래스인 기준 클래스(Base Class)로부터 상속하여 새로운 파생 클래스(Derived Class)를 만들 수 있다. 상속(inheritance)을 사용하게 되면 Base 클래스의 데이타 및 메서드들을 (public 혹은 protected 멤버의 경우) 파생클래스에서 사용할 수 있게 된다. 파생 클래스는 Base 클래스로부터 물려 받는 멤버들 외에 대개 자기 고유의 메서드와 데이타를 추가해서 사용하게 된다.

C#에서 파생클래스를 정의하기 위해서는 클래스명 뒤에 Colon (:)을 찍고 Base 클래스명을 써 주면 된다. 제약점은 C#에서는 파생클래스가 단 하나의 Base 클래스로부터 상속되어져야 한다는 것이다. 즉, 하나의 파생클래스는 2개 이상의 Base 클래스를 가질 수 없다. 아래 예는 Base 클래스(Animal)로부터 Dog과 Bird라는 파생클래스들을 생성하는 예이다. 예제에서 각 파생클래스는 Base 클래스로부터 상속된 속성(Property)을 사용하고 있다.

```cs
// 베이스 클래스
public class Animal
{
   public string Name { get; set; }
   public int Age { get; set; }
}

// 파생클래스
public class Dog : Animal
{       
   public void HowOld() 
   {
      // 베이스 클래스의 Age 속성 사용
      Console.WriteLine("나이: {0}", this.Age);
   }
}

public class Bird : Animal
{       
   public void Fly()
   {
      Console.WriteLine("{0}가 날다", this.Name);
   }
}
```

#### 추상 클래스 (Abstract Class)

C#의 클래스명 앞에 abstract라는 C# 키워드 붙이는 경우가 있다. 이를 추상 클래스(Abstract Class)라고 하는데, 이러한 추상클래스로부터는 객체를 직접 생성할 수 없다. 즉, new를 이용하여 클래스 객체를 생성할 수 없다.

또한 추상 클래스 안에 클래스의 임의의 멤버 앞에 abstract 키워드를 붙이는 경우가 있는데, 이는 해당 멤버가 구현되지 않았으며, 추상 클래스로부터 파생되는 파생클래스에서 반드시 그 멤버를 구현해 주어야 한다는 것을 의미한다. 파생 클래스에서 상속된 abstract 메서드를 구현하기 위해서는 override 라는 C# 키워드를 사용하여 그 메서드를 새로 정의하면 된다.

```cs
public abstract class PureBase
{
   // abstract C#키워드 
   public abstract int GetFirst();
   public abstract int GetNext();   
}

public class DerivedA : PureBase
{
   private int no = 1;

   // override C#키워드 
   public override int GetFirst()
   {
      return no;
   }

   public override int GetNext()
   {
      return ++no;
   }
}
```

#### 분할 클래스(partial class, C# 2.0 이후)

C# 2.0에서 partial 키워드가 도입되어 Partial Class, Partial Struct, Partial Interface 를 사용할 수 있게 되었다. 기본적으로 이들 Partial 타입들이 만든어진 이유는 Code Generator가 만든 코드와 사용자가 만드는 코드를 분리하기 위함이다. 예를 들어, 윈폼에서는 Form UI 디자인과 관련된 Form1.designer.cs 파일과 사용자가 쓰는 Form1.cs 파일에 동일한 클래스명을 두고 이를 partial로 선언하는데, 컴파일러는 나중에 이를 합쳐 하나의 클래스로 만든다. 또한, ASP.NET 웹폼에서는 하나의 웹페이지를 만들 때, page1.aspx, page1.aspx.designer.cs, page1.aspx.cs와 같이 3개의 파일을 만드는데, XML인 page1.aspx 이외의 .cs 파일 안에는 윈폼과 마찬가지고 partial 클래스를 사용하고 있다. 웹 개발자는 Code Behind라 불리우는 page1.aspx.cs 파일에서 주로 작업한다. 이러한 Partial 기능은 개발자에게 포커스 해야하는 코드를 분리해 준다는 점에서 크게 도움이 된다.

클래스의 구현이 길어질 경우 소스파일로 분할하여 동시에 작업을 수행하거나, 관리의 편의를 위해 클래스를 분할하는 경우가 있다. 이 경우 클래스의 선언 앞 부분에 partial 을 붙여 여러 부분으로 나누어 선언할 수 있다. 

```cs
using System;

namespace Example
{
    partial class Nested
    {
        public void Test() { Console.WriteLine("Test()"); }
    }
    partial class Nested
    {
        public void Test2() { Console.WriteLine("Test2()"); }
    }
    partial class Nested
    {
        public void Test3() { Console.WriteLine("Test3()"); }
    }
    class Program
    {
        static void Main(string[] args)
        {
            Nested nested = new Nested();
            nested.Test();
            nested.Test2();
            nested.Test3();
        }
    }
}
```

#### 중첩 클래스(Nested Class)

C#에서는 클래스 내부에 클래스의 선언이 가능합니다. 만약 접근 제한자가 명시되어 있지 않으면 private로 보호 수준이 지정됩니다. 때문에 특별한 경우가 아니면 중첩 클래스는 외부로 보여지지 않습니다. 

```cs
class 클래스명
{
    class 클래스명
    {
        ..
    }
}
```

#### as-is 캐스팅(클래스 캐스팅과의 차이점)

C#의 as 연산자는 객체를 지정된 클래스 타입으로 변환하는데 사용한다. 만약 변환이 성공하면 해당 클래스 타입으로 캐스팅하고, 변환이 실패하면 null 을 리턴한다.

이와는 대조적으로 캐스팅(Casting)을 사용하면, 변환이 실패했을 때 Exception을 발생시키게 되는데, 이를 catch하지 않으면 프로그램을 중지하게 된다.

C#의 is 연산자는 is 앞에 있는 객체가 특정 클래스 타입이나 인터페이스를 갖고 있는지 확인하는데 사용한다.

```cs
class MyBase { }
class MyClass : MyBase { }

class Program
{
    static void Main(string[] args)
    {
        MyClass c = new MyClass();
        new Program().Test(c);
    }

    public void Test(object obj)
    {
        // as 연산자
        MyBase a = obj as MyBase; 

        // is 연산자
        bool ok = obj is MyBase; //true

        // Explicit Casting
        MyBase b = (MyBase) obj; 
    }
}
```

### 인터페이스(Interface)

클래스와 비슷하게 인터페이스는 메서드, 속성, 이벤트, 인덱서 등을 갖지만, 인터페이스는 이를 직접 구현하지 않고 단지 정의(prototype definition)만을 갖는다. 즉, 인터페이스는 추상 멤버(abstract member)로만 구성된 추상 Base 클래스(abstract base class)와 개념적으로 유사하다. 클래스가 인터페이스를 가지는 경우 해당 인터페이스의 모든 멤버에 대한 구현(implementation)을 제공해야 한다.

한 클래스는 하나의 Base 클래스만을 가질 수 있지만, 인터페이스는 여러 개를 가질 수 있다. 아래의 예를 보면, MyConnection 이라는 클래스는 Component 라는 하나의 Base 클래스와 IDbConnection, IDisposable이라는 2개의 인터페이스를 가지고 있음을 알 수 있다.

```cs
public class MyConnection : Component, IDbConnection, IDisposable
{
   // IDbConnection을 구현
   // IDisposable을 구현
}
```
#### 인터페이스의 정의

인터페이스는 C# 키워드 interface를 사용하여 정의한다. 인터페이스 정의 시에는 (메서드와 같은) 내부 멤버들에 대해 public과 같은 접근 제한자를 사용하지 않는다.
예를 들어, 아래 예제에서 CompareTo() 메서드 앞에 public 을 쓸 수 없다.

```cs
public interface IComparable
{
   // 멤버 앞에 접근제한자 사용 안함
   int CompareTo(object obj);
}
```

#### C# 인터페이스의 사용

C# 실무에서 클래스와 인터페이스를 잘 정의하고 사용하는 것은 매우 중요하다. 비지니스를 객체지향 프로그래밍으로 디자인하고 구현하는데 가장 중요한 핵심이기 때문이다. 자연스럽게 .NET Framework도 상당히 많은 인터페이스를 구현했으며, 거의 모든 영역에서 흔히 사용되고 있다.

다음 코드는 IDbConnection이라는 인터페이스를 사용하는 예제이다. 이 코드에서 GetDbConnection() 메서드는 시스템의 구성파일로부터 DB타입과 Connection String을 받아와 해당 DB타입에 맞는 데이타베이스 Connection을 리턴한다. GetDbConnection()가 DB connection을 리턴할 때 IDbConnection을 리턴하고 있는데, 이 때문에 이 메서드를 사용하는 클라이언트에서는 어떤 DB를 사용하든지 상관없이 모든 DB 클래스에 공통적으로 구현된 IDbConnection 멤버들을(메서드, 속성등) 사용할 수 있게 된다.

```cs
public void Run()
{
   // 인터페이스 사용하기 때문에
   // 특정 DB Connection을 신경 쓸 필요가 없다
   IDbConnection dbCon = GetDbConnection();
   dbCon.Open();
   if (dbCon.State == ConnectionState.Open)
   {
      dbCon.Close();
   }
}

// IDbConnection 인터페이스를 리턴
public IDbConnection GetDbConnection()
{
   IDbConnection dbConn = null;
   string cn = ConfigurationManager.AppSettings["Connection"];
   switch (ConfigurationManager.AppSettings["DbType"])
   {
      case "SQLServer":
         dbConn = new SqlConnection(cn);
         break;
      case "Oracle":
         dbConn = new OracleConnection(cn);
         break;
      case "OleDB":
         dbConn = new OleDbConnection(cn);
         break;         
   }
   return dbConn;
}
```

### 접근 제한자 (Access Modifier)

접근 제한자는 외부로부터 타입(클래스, 구조체, 인터페이스, 델리게이트 등) 혹은 그 타입 멤버들(메서드, 속성, 이벤트, 필드 등)로의 접근을 제한할 때 사용하는 것으로 다음과 같은 종류가 있다.

- public: 모든 외부(파생클래스 포함)에서 이 타입(Type: 클래스, 구조체, 인터페이스, 델리게이트 등)을 엑세스할 수 있다. (개별 타입 멤버의 엑세스 권한은 해당 멤버의 접근 제한자에 따라 별도로 제한될 수 있다)
- internal: 동일한 Assembly 내에 있는 다른 타입들이 엑세스 할 수 있다. 하지만, 다른 어셈블리에서는 접근이 불가하다.
- protected: 파생클래스에서 이 클래스 멤버를 엑세스할 수 있다.
- private: 동일 클래스/구조체 내의 멤버만 접근 가능하다.

접근 제한자는 public class A {} 와 같이 클래스, 구조체와 같은 Type 앞에 사용하거나 메서드, 속성, 필드 등의 클래스/구조체 멤버 앞에 사용하여 (예: protected int GetValue(); ) 접근을 제한하게 된다.

- 클래스 멤버는 5가지의 접근 제한자를 (public, internal, private, protected, protected internal) 모두 가질 수 있지만, 구조체(struct) 멤버는 상속이 되지 않으므로 3가지의 접근 제한자만 (public, internal, private) 가질 수 있다.
- 보통 클래스와 구조체는 네임스페이스 바로 밑에 선언하는데,이때 디폴트로 internal 접근 제한을 갖는다. 단, 클래스 내부에 Nested 클래스를 선언하는 것과 같이 Nested Type을 선언하면 디폴트로 private 접근 제한을 갖는다.
- 인터페이스(interface)와 열거형(enum)의 멤버는 기본적으로 public 이며, 각 멤버에 별도의 접근 제한자를 사용하지 않는다.

#### 접근 제한자 사용

클래스의 필드는 기본적으로 private으로 설정하여 외부로터의 접근을 완전히 제한하는 것이 일반적이다 (객체 지향 프로그래밍의 원칙에 따라). 메서드는 외부에서 호출해야 하는 것은 public으로 하고 내부에서만 사용되는 것은 private으로 설정한다. 메서드는 이외에도 어셈블리 내부에서만 사용 가능한 internal, 파생클래스에서 엑세스할 수 있는 protected 를 사용할 수 있다. 속성은 메서드와 동일한 방식으로 설정한다.

```cs
internal class MyClass
{
   private int _id = 0; 

   public string Name { get; set; }

   public void Run(int id) {}

   protected void Execute() { }
}
```

- MyClass는 internal 클래스로서 동일 어셈블리 내의 다른 타입만 이 클래스로 접근할 수 있다.
- _id 는 private 필드로서 클래스 내부에서만 사용 가능하다 .
- Name은 public 프로퍼티로서 클래스를 엑세스할 수 있는 모든 외부 객체에서 접근 가능하다.
- Run()은 public 메서드로서 클래스를 엑세스할 수 있는 모든 객체에서 접근 가능하다.
- Execute()는 protected 메서드로서 해당 MyClass와 이의 파생 클래스에서만 접근 가능하다.


### 메서드(Method)

클래스내에서 일련의 코드 블럭을 실행시키는 함수를 메서드라 부른다. 메서드는 0 ~ N개의 인수를 갖을 수 있으며, 하나의 리턴 값을 갖는다. 리턴 값이 없으면 리턴 타입을 void로 표시한다. 또한 public, private 같은 접근 제한자를 리턴 타입 앞에 둘 수 있다. 아래는 전형적인 메서드의 예이다. 이는 a,b,c 라는 3개의 인수를 받아 들이고, int 타입의 데이타를 리턴하는 public 메서드이다.

```cs
public int GetData(int a, string b, bool c)
{
}
```

#### Pass by Value

C#은 메서드에 인수를 전달할 때, 디폴트로 값을 복사해서 전달하는 Pass by Value 방식을 따른다. 만약 전달된 인수를 메서드 내에서 변경한다해도 메서드가 끝나고 함수가 리턴된 후, 전달되었던 인수의 값은 호출자에서 원래 값 그대로 유지된다.

```cs
class Program
{
    private void Calculate(int a)
    {
        a *= 2;
    }

    static void Main(string[] args)
    {
        Program p = new Program();

        int val = 100;
        p.Calculate(val);  
        // val는 그대로 100        
    }
}
```

#### Pass by Reference

메서드에 파라미터를 전달할 때, 만약 레퍼런스(참조)로 전달하고자 한다면 C# 키워드 ref를 사용한다. ref를 사용할 경우 메서드 내에서 변경된 값은 리턴 후에도 유효하다. ref를 사용하기 위해서는 ref로 전달되는 변수가 사전에 초기화되어져야 한다.

C#의 ref와 비슷한 기능을 하는 것으로 C# out 키워드가 있다. out을 사용하는 파라미터는 메서드 내에서 그 값을 반드시 지정하여 전달하게 되어 있다. C#의 ref는 해당 변수가 사전에 초기화되어야 하지만, C# out은 사전에 변수를 초기화할 필요는 없다.

```cs
// ref 정의
static double GetData(ref int a, ref double b)
{ return ++a * ++b; }

// out 정의
static bool GetData(int a, int b, out int c, out int d)
{
    c = a + b;
    d = a - b;
    return true;
}

static void Main(string[] args)
{
    // ref 사용. 초기화 필요.
    int x = 1;
    double y = 1.0;
    double ret = GetData(ref x, ref y);

    // out 사용. 초기화 불필요.
    int c, d;
    bool bret = GetData(10, 20, out c, out d);
}
```

#### Named Parameter(C# 4.0 이후)

메서드에 파라미터를 전달할 때, 일반적으로 파라미터 위치에 따라 순차적으로 파라미터가 넘겨지는데, C# 4.0부터는 위치와 상관없이 파라미터명을 지정하여 파라미터를 전달할 수 있게 하였다. 이러한 파라미터를 Named Parameter라 부른다.

```cs
Method1(name: "John", age: 10, score: 90);
```

#### Optional Parameter(C# 4.0 이후)

C# 4.0에서부터 어떤 메서드의 파라미터가 디폴트 값을 갖고 있다면, 메서드 호출시 이러한 파라미터를 생략하는 것을 허용하였다. 이렇게 디폴트 값을 가진 파라미터를 Optional 파라미터라 부른다. Optional 파라미터는 반드시 파라미터들 중 맨 마지막에 놓여져야 한다. 복수개의 Optional 파라미터가 있는 경우 반드시 Optional 이 아닌 파라미터들 뒤에 위치해야 한다.

```cs
class Program
{
    // Optional 파라미터: calcType
    int Calc(int a, int b, string calcType = "+")
    {
        switch (calcType)
        {
            case "+":
                return a + b;
            case "-":
                return a - b;
            case "*":
                return a * b;
            case "/":
                return a / b;
            default:
                throw new ArithmeticException();
        }
    }

    static void Main(string[] args)
    {
        Program p = new Program();
        int ret = p.Calc(1, 2);
        ret = p.Calc(1, 2, "*");
    }
}
```

#### 가변 배열 인자(Params)

일반적으로 메서드의 파라미터 갯수는 고정되어 있다. 하지만 어떤 경우는 파라미터의 갯수를 미리 알 수 없는 경우도 있는데, 이런 경우 C# 키워드 params를 사용한다. 이 params 키워드는 가변적인 배열을 인수로 갖게 해주는데, 파라미터들 중 반드시 하나만 존재해야 하며, 맨 마지막에 위치해야 한다.

```cs
//메서드
 int Calc(params int[] values)

//사용
int s = Calc(1,2,3,4);
s = Calc(6,7,8,9,10,11);
```
#### 확장 메소드(Extension Method, C# 3.0 이후)

C# 3.0부터 지원하는 확장메서드(Extension Method)는 특수한 종류의 static 메서드인데, 확장메서드는 마치 다른 클래스(혹은 구조체)의 인스턴스 메서드인 것처럼 사용되는 기능을 제공한다. 확장메서드는 클래스, 구조체, 인터페이스 등에 적용될 수 있다.

일반적으로 인스턴스 메서드를 추가하기 위해서는 해당 클래스 (혹은 타입) 안에 메서드를 추가한다. 하지만, 어떤 경우는 메서드를 클래스 (혹은 타입)에 직접 추가하는 것이 어려울 수도 있는데, 이러한 경우 확장메서드가 유용하게 사용될 수 있다. 확장메서드를 사용하면 클래스를 직접 변경하지 않고도, 클래스 외부에서 (확장)메서드를 정의함으로 해서 마치 그 클래스의 기능을 확장한 인스턴스 메서드를 추가한 것 같은 효과를 낼 수 있다.

```cs
namespace 네임스페이스명
{
    public static class 클래스명
    {
        public static 반환형식 메소드명(this 확장대상형식 식별자, 매개변수..)
        {
            ..
        }
        ..
    }
}
```

```cs
using System;
using Extension;
 
namespace Extension
{
    public static class ExtensionMethod
    {
        public static int Multiplication(this int var, int a, int b)
        {
            int result = var;
 
            for (int i = 0; i < b; i++)
                result *= a;
 
            return result;
        }
    }
}
 
namespace Example
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("{0}", 5.Multiplication(2, 3));
        }
    }
}
```

확장메서드는 static class 안에 static method로 정의된다. 확장메서드는 첫번째 파라미터로 항상 클래스명(혹은 타입)을 지정하는데, 이는 그 확장메서드가 사용될 클래스 타입을 지정하는 것이다. 이를 통해 확장메서드는 마치 그 클래스의 인스턴스 메서드인 것처럼 사용할 수 있게 된다. 약간 특이한 문법이지만, 확장 메서드의 첫번째 파라미터의 클래스명 바로 앞에는 항상 this를 써준다.

아래 예제는 .NET의 String 클래스를 첫번째 파라미터로 갖는 확장메서드로서, String 클래스에서만 동작하는 확장메서드를 정의한 예이다. ToChangeCase(this String str) 메서드는 파라미터가 하나로서 String 클래스에서 사용되는 확장메서드이며 그 메서드는 다른 입력파라미터를 갖지 않지만, Found(this String str, char ch) 메서드는 String 클래스에서 사용되는 확장메서드로서 char 문자 하나를 입력파라미터로 받아들이는 메서드이다.

```cs
using System;
using System.Text;

namespace MySystem
{
   // static class를 정의
   public static class ExClass
   {
      // static 확장메서드를 정의. 첫번째 파라미터는
      // 어떤 클래스가 사용할 지만 지정. 
      public static string ToChangeCase(this String str)
      {
         StringBuilder sb = new StringBuilder();
         foreach (var ch in str)
         {
            if (ch >= 'A' && ch <= 'Z')
               sb.Append((char)('a' + ch - 'A'));
            else if (ch >= 'a' && ch <= 'z')
               sb.Append((char)('A' + ch - 'a'));
            else
               sb.Append(ch);
         }
         return sb.ToString();
      }

      // 이 확장메서드는 파라미터 ch가 필요함
      public static bool Found(this String str, char ch)
      {
         int position = str.IndexOf(ch);
         return position >= 0;
      }
   }

   class Program
   {
      static void Main(string[] args)
      {
         string s = "This is a Test";
         
         // s객체 즉 String객체가
         // 확장메서드의 첫 파리미터임
         // 실제 ToChangeCase() 메서드는
         // 파라미터를 갖지 않는다.
         string s2 = s.ToChangeCase();

         // String 객체가 사용하는 확장메서드이며
         // z 값을 파라미터로 사용
         bool found = s.Found('z');
      }
   }
}
```

특히, 추가 상속이 불가능한 클래스에 대하여 유용하게 사용이 가능하다. 

#### Enumerable 확장 메소드 예시

System.Linq.Enumerable 클래스는 LINQ 쿼리에서 사용되는 많은 확장 메서드들을 포함하는 클래스이다. 한 예를 들어, Enumerable 클래스는 다음과 같은 Where() 확장메서드를 포함하고 있다. 첫번째 파라미터는 이 메서드가 IEnumerable<T> 인터페이스를 지원하는 모든 Type에 사용된다는 것을 의미한다. 두번째 파라미터는 Func 라는 Delegate를 받아들인다는 것을 의미하는데, 보통 여기에는 LINQ 쿼리를 람다식 (Lambda Expression)으로 표현하여 넣게 된다.

```cs
// LINQ에 정의된 Where 확장메서드

public static IEnumerable<TSource> Where<TSource>(
    this IEnumerable<TSource> source, 
    Func<TSource, bool> predicate
)
```

아래는 Where() 확장메서드를 사용하는 예제이다. Where() 확장메서드의 첫번째 파라미터에 해당되는 this IEnumerable<T>은 IEnumerable<T>를 갖는 클래스에서 사용된다는 의미인데, 변수 list 객체가 IEnumerable을 구현한 문자열 리스트이므로 list.Where()처럼 사용할 수 있다. 아래 예에서 Where() 안의 파라미터는 람다식 표현으로 Element중 A로 시작되는 문자열들만 선별하는 것을 의미한다.

```cs
// Where 확장메서드를 List<T>에서 사용

List<string> list = new List<string> { "Apple", "Grape", "Banana" };
IEnumerable<string> q = list.Where(p => p.StartsWith("A"));
```

또 다른 예로서 아래 예제는 Where() 확장 메서드를 정수 리스트에 적용하여 3으로 나누어 떨어지는 데이타만 출력해 본 것이다. Where()의 리턴 값은 IEnumerable<int>인데, 이를 동적배열(List)로 변경하기 위해 ToList() 메서드를 사용하였다.

```cs
static void Main(string[] args)
{
   List<int> nums = new List<int> { 55, 44, 33, 66, 11 };

   // Where 확장 메서드 정수 리스트에 사용
   var v = nums.Where(p => p % 3 == 0);

   // IEnumerable<int> 결과를 정수리스트로 변환
   List<int> arr = v.ToList<int>();

   // 리스트 출력
   arr.ForEach(n => Console.WriteLine(n));
}
```

#### C# static 메서드

정적(Static) 메서드는 인스턴스 메서드와는 달리 클래스로부터 객체를 생성하지 않고 직접 [클래스명.메서드명] 형식으로 호출하는 메서드이다. 이 메서드는 메서드 앞에 static 이라는 C# 키워드를 적어 주며, 메서드 내부에서 클래스의 인스턴스 객체 멤버를 참조해서는 안된다. 이 static 메서드는 인스턴스 객체로부터 호출될 수 없으며, 반드시 클래스명과 함께 사용된다.

```cs
public class MyClass
{
   private int val = 1;
   
   // 인스턴스 메서드
   public int InstRun()
   {
      return val;
   }
   
   // 정적(Static) 메서드
   public static int Run() 
   {
      return 1;
   }
}

public class Client
{
   public void Test()
   {
      // 인스턴스 메서드 호출
      MyClass myClass = new MyClass();
      int i = myClass.InstRun();

      // 정적 메서드 호출
      int j = MyClass.Run();
   }
}
```

정적(Static) 속성 및 필드는 위의 static 메서드와 같이 [클래스명.속성명]과 같이 사용하며, 다음 예와 같이 static을 앞에 붙여 정의한다. 클래스 내의 Non-static 필드들은 클래스 인스턴트를 생성할 때마다 메모리에 매번 새로 생성되게 되는 반면, static 필드는 프로그램 실행 후 해당 클래스가 처음으로 사용될 때 한번 초기화되어 계속 동일한 메모리를 사용하게 된다.

```cs
// static 필드
protected static int _id;

// static 속성
public static string Name { get; set; }
```

#### C# 무명 메서드 (Anonymous Method)

앞의 C# delegate 예제를 보면 예제의 delegate들은 모두 이미 정의된 메서드를 가리키고 있었다. 이렇게 미리 정의된 메서드들과는 달리, C# 2.0에서부터 메서드를 미리 정의하지 않아도 되는 메서드명이 없는 무명 메서드 (혹은 익명 메서드, Anonymous Method)를 지원하게 되었다. 만약 어떤 메서드가 일회용으로 단순한 문장들로 구성되어 있다면, 굳이 별도의 메서드를 정의하지 않아도 되는 것이다.

무명 메서드를 만들기 위해서는 delegate 키워드와 함께 아래와 같이 파라미터와 실행 문장 블럭을 적으면 된다. delegate 뒤의 파라미터는 해당 메서드 원형(Prototype)에 맞는 동일한 파라미터 타입이어야 하며, 실행문장블럭에는 여러 문장들을 쓸 수 있다. 무명 메서드는 외관상 인라인 메서드(inline method) 형식을 띠며, 무명 메서드 자체를 delegate 타입의 변수에 할당할 수도 있다.

```cs
// 무명메서드 형식: delegate(파라미터들) { 실행문장들 };

delegate(int param1) { Console.Write(param1); };


// 무명메서드를 delegate 타입 변수에 할당

delegate void MyDelegate(int a);

MyDelegate d = delegate(int p) 
{ 
   Console.Write(p); 
};

d(100);
```

C# 무명 메서드를 사용하기 위해서는 메서드가 필요한 곳에 직접 delegate로 시작하는 무명 메서드를 써주면 된다. 예를 들어, 무명 메서드를 델리게이트 변수에 할당해서 사용할 수도 있고, 메서드의 파라미터에 인라인 형식으로 무명 메서드를 사용할 수도 있으며, 또한 이벤트 핸들러를 추가하는 곳에 무명메서드를 사용할 수 있다.

아래 예제는 이벤트 핸들러에 무명 메서드를 사용한 예이다. 예제에서 button1.Click 에는 미리 정의된 메서드명(button1_Click) 을 가리키는 이벤트 핸들러를 지정하였고, button2.Click 에서는 무명메서드를 사용하여 직접 간단한 문장을 인라인으로 delegate(){ ... }안에 포함시킨 것이다.

```cs
public partial class Form1 : Form
{
   public Form1()
   {
      InitializeComponent();

      // 메서드명을 지정
      this.button1.Click += new System.EventHandler(this.button1_Click);

      // 무명메서드를 지정
      this.button2.Click += delegate(object s, EventArgs e)
      {
         MessageBox.Show("버튼2 클릭");
      };
   }

   private void button1_Click(object sender, EventArgs e)
   {
      MessageBox.Show("버튼1 클릭");
   }
}
```

#### C# Partial Method

C# 3.0에서는 C# 2.0에서 소개된 3개의 partial type들 이외에 새로운 partial 기능을 하나 추가하였다. 즉, partial 기능을 Type이 아닌 메서드에 적용한 Partial Method 기능이다. Partial Method는 그 전제 조건으로 메서드가 반드시 Private 메서드이어야 하고, 리턴 값이 없어야(void) 한다.

사용하는 방법은 아래 예제에서 보이듯이, 첫번째 파일(or 클래스)에 void DoThis(); 와 같이 메서드 Body가 없이 메서드 선언부만 적는다. 그리고 구현 파일에서 DoThis() { ... } 와 같이 실제 메서드를 구현한다.
여기서 한가지 주목한 점은 만약 두번째 실제 메서드 구현이 생략되고 메서드 선언부만 있게 된다면, C# 컴파일러는 컴파일시 DoThis() 전체를 없애 버린다는 것이다. 즉, 특정 메서드가 다른 파일에서 구현되었는가의 여부에 따라 메서드 전체를 생략할 수 있는 기능을 제공하는 것이다.

```cs
// Partial Method (C# 3.0)
public partial class Class2
{
    public void Run()
    {
        DoThis();
    }

    // 조건1: private only
    // 조건2: void return only
    partial void DoThis();
}

public partial class Class2
{
    partial void DoThis()
    {
        Log(DateTime.Now);
    }
}
```

### 람다식 (Lambda Expression) (=>)

C# 3.0부터 지원하는 => 연산자는 C#에서 람다식(Lambda Expression)을 표현할 때 사용한다. 람다식은 무명 메서드와 비슷하게 무명 함수(anonymous function)를 표현하는데 사용된다. 람다식은 아래와 같이 입력 파라미터(0개 ~ N개)를 => 연산자 왼쪽에, 실행 문장들을 => 연산자 오른쪽에 둔다.

```cs
람다식 문법 : (입력 파라미터) => { 실행문장 블럭 };
str => { MessageBox.Show(str); }
```

입력 파라미터는 하나도 없는 경우부터 여러 개 있는 경우가 있다. 다음 예제는 파라미터가 없는 경우, 한개 있는 경우, 두개 있는 경우를 예시한 것이다. 마지막 예는 입력 파라미터의 타입이 모호한 경우 이를 써줄 수 있음을 예시한 것이다. 일반적으로 입력타입은 컴파일러가 알아서 찾아낸다.

```cs
// 입력 파라미터가 없는 경우
() => Write("No");

// 입력 파라미터가 1~2개 있는 경우
(p) => Write(p);
(s, e) => { Write(s); Write(e); }

// 입력 파라미터 타입을 명시하는 경우
(string s, int i) => Write(s, i);
```

람다식(Lambda Expression)을 이용하면 이전 아티클에 소개한 delegate 와 무명 메서드를 더 간략히 표현할 수 있다. 예를 들어 다음과 같은 Click 이벤트는 이벤트 핸들러 메서드인 button1_Click를 추가하고 있는데, 그래서 메서드 button1_Click은 해당 클래스 내 어딘가에 정의되어 있어야 한다.

```cs
/* 함수 선언을 이용한 이벤트 추가 */
this.button1.Click += new System.EventHandler(button1_Click);
//또는
this.button1.Click += button1_Click;

private void button1_Click(object sender, EventArgs e)
{
   ((Button)sender).BackColor = Color.Red;
}
```

```cs
/* 무명 메서드를 이용한 이벤트 추가 */
this.button1.Click += delegate(object sender, EventArgs e)
{
   ((Button)sender).BackColor = Color.Red;
};
```

```cs
/* 람다식을 이용한 이벤트 추가 */
this.button1.Click += (sender, e) => ((Button)sender).BackColor = Color.Red;
```

람다식(Lambda Expression)은 .NET Framework의 여러 곳에서 사용되지만, 특히 LINQ (Language Integrated Query) 에서 많이 사용된다. LINQ는 별도의 주제이지만 간단한 예를 들면, 아래는 람다식이 LINQ의 Where 쿼리 안에서 사용된 예이다.

```cs
// LINQ Where() 메서드 안에서 사용된 람다식

var projs = db.Projects.Where(p => p.Name == strName);
```

### 이벤트(Event)

이벤트는 클래스내에 특정한 일(event)이 있어났음을 외부의 이벤트 가입자(subscriber)들에게 알려주는 기능을 한다. C#에서 이벤트는 event라는 키워드를 사용하여 표시하며, 클래스 내에서 일종의 필드처럼 정의된다.

이벤트에 가입하는 외부 가입자 측에서는 이벤트가 발생했을 때 어떤 명령들을 실행할 지를 지정해 주는데, 이를 이벤트 핸들러라 한다. 이벤트에 가입하기 위해서는 += 연산자를 사용하여 이벤트핸들러를 이벤트에 추가한다. 반대로 이벤트핸들러를 삭제하기 위해서는 -= 연산자를 사용한다. 하나의 이벤트에는 여러 개의 이벤트핸들러들을 추가할 수 있으며, 이벤트가 발생되면 추가된 이벤트핸들러들을 모두 차례로 호출한다.

다음 코드는 클래스(MyButton) 내에서 이벤트(Click)를 정의하고 이를 사용하는 예제이다.

```cs
// 클래스 내의 이벤트 정의
class MyButton
{
   public string Text;
   // 이벤트 정의
   public event EventHandler Click;

   public void MouseButtonDown()
   {
      if (this.Click != null)
      {
         // 이벤트핸들러들을 호출
         Click(this, EventArgs.Empty);
      }
   }
}

// 이벤트 사용
public void Run()
{
   MyButton btn = new MyButton();
   // Click 이벤트에 대한 이벤트핸들러로
   // btn_Click 이라는 메서드를 지정함
   btn.Click += new EventHandler(btn_Click);
   btn.Text = "Run";
   //....
}

void btn_Click(object sender, EventArgs e)
{
   MessageBox.Show("Button 클릭");
}
```

- 이벤트 Click은 외부에서 엑세스할 수 있게 public 필드로 정의되어 있다.
- MouseButtonDown() 메소드에서 이벤트를 외부로 보내기 전에 이벤트에 가입한 가입자들이 있는지 체크하기 위해 if (Click != null)을 사용한다.
- 이벤트에 가입하거나 탈퇴하기 위해서는 += (subscribe) 또는 -= (unsubscribe)연산자를 사용한다.
- 여기서 void btn_Click(object sender, EventArgs e) 메서드는 이벤트핸들러로 사용되고 있다.

#### Event Method: Add, Remove

C# 클래스의 속성(Property)에서 get, set 을 사용하듯이 event 에서는 add, remove 를 사용할 수 있다. 속성의 get, set에서 값을 대입하거나 리턴하는 일 이외에 간단한 체크 코드를 실행하는 것처럼 event 의 add, remove문에서도 이러한 코드를 넣을 수 있다. 아래 예제에서, add 문은 += 를, remove 문은 -= 을 사용하고 있는데, 이는 _click 이벤트 안에 있는 내부 리스트에 (주: 이를 InvocationList라 하고 _click.GetInvocationList()를 사용해서 리스트를 얻을 수 있다) value 델리게이트를 추가하거나 삭제하는 기능을 한다. 여러 개의 델리게이트를 가지고 순서대로 호출하는 것을 멀티캐스트(Multicast) 델리게이트라 하는데, 델리게이트는 멀티캐스트를 디폴트로 한다.

만약 add 문에서 +- 대신 = 을 사용하면 이는 기존 InvocationList의 내용을 지우고 할당된 새 value 델리게이트 하나만 추가하게 된다. 이는 특별한 용도로 Singlecast를 구현할 때 사용한다.

```cs
class MyButton
{
    // 이벤트 정의하는 다른 방법
    private EventHandler _click;
    public event EventHandler Click
    {
        add
        {
            _click += value;
            // _click = value;   // 싱글캐스트
        }
        remove
        {
            _click -= value;
        }
    }

    public void MouseButtonDown()
    {
        if (this._click != null)
        {
            // 이벤트핸들러들을 호출
            _click(this, EventArgs.Empty);                                
        }
    }

    /* 속성 정의
    private string _name;
    public string Name 
    {
        get
        {
            return _name;
        }
        set
        {
            _name = value;
        }
    }
    */
}
```

### 전처리기 지시어 (Preprocessor Directive)

C# 전처리기 지시어 (Preprocessor Directive)는 실제 컴파일이 시작되기 전에 컴파일러에게 특별한 명령을 미리 처리하도록 지시하는 것이다. 모든 C# 전처리기 지시어는 # 으로 시작되며, 한 라인에 한 개의 전처리기 명령만을 사용한다. 전처리기 지시어는 C# Statement가 아니기 때문에 끝에 세미콜론(;)을 붙이지 않는다.

전처리기 지시어는 해당 파일 안에서만 효력을 발생한다. 만약 하나의 클래스가 두개의 파일에 나뉘어 Partial Class로 저장되었을 때, 두개의 파일에서 동일한 심벌(#define으로 정의)을 사용하고 싶다면, 두개의 파일에 각각 심벌을 정의해야 한다. C# 전처리기는 C/C++와 달리 별도의 Preprocessor를 갖지 않고 컴파일러가 Preprocessor Directive를 함께 처리한다.

#### 조건별 컴파일

C# 전처리기에서 자주 사용되는 것으로 #define과 #if ... #else ... #endif 가 있다. #define은 심벌을 정의할 때 사용하는데, 예를 들어, #define DEBUG 혹은 #define RELEASE와 같이 하나의 심벌을 정의한다. 이렇게 정의된 심벌은 다른 전처리기 지시어에서 사용되는데, 예를 들어 #if (DEBUG)와 같이 if 지시어에서 사용될 수 있다.

흔히 #define과 #if를 결합하여 조건별로 서로 다른 코드 블럭을 컴파일하도록 할 수 있다. 아래 코드는 TEST_ENV 라는 심벌을 정의되었지를 보고 서로 다른 코드 블럭을 컴파일하는 예를 보여주고 있다. Visual Studio에서는 조건별로 컴파일 되지 못하는 영역은 회색으로 표시해 준다.

```cs
#define TEST_ENV
//#define PROD_ENV

using System;

namespace App1
{
    class Program
    {
        static void Main(string[] args)
        {
            bool verbose = false;
            // ...

#if (TEST_ENV)
            Console.WriteLine("Test Environment: Verbose option is set.");
            verbose = true;
#else
            Console.WriteLine("Production");
#endif

            if (verbose)
            {
                //....
            }
        }
    }
}
```

#### #region 전처리기 지시어

#region은 코드 블럭을 논리적으로 묶을 때 유용하다. 예를 들어, Public 메서드들만 묶어 [Public Methods]라고 명명할 수 있고, Private 메소드들을 묶어 [Privates] 라고 명명할 수 있다.

#region은 #endregion과 쌍을 이루며 한 영역을 형성한다. #region 안에 다른 Nested Region을 둘 수도 있다. Visual Studio에서 #region 영역은 좌측에 +/- 로 표시되어 Expand/Collapse를 할 수 있는 기능을 제공한다. 이 전처리기 지시어는 실제 가장 많이 사용되는데, 특히 복잡하고 긴 클래스를 개념적으로 묶을 때 매우 유용하다.

```cs
class ClassA
{
    #region Public Methods        
    public void Run() { }
    public void Create() { }        
    #endregion

    #region Public Properties
    public int Id { get; set; }
    #endregion

    #region Privates
    private void Execute() { }
    #endregion
}
```

#### #pragma 전처리기 지시어

#pragma 지시어는 위의 표준 C# 전처리기 지시어와 다르게, 컴파일러 제작업체가 고유하게 자신들의 것을 만들어 사용할 수 있는 지시어이다. 즉, 어떤 컴파일러를 쓰느냐에 따라 지원되는 #pragma가 서로 다르며, 개발자가 임의로 지정하여 사용할 수 없다.

MS의 C# 컴파일러는 현재 #prama warning과 #pragma checksum 2개를 지원하고 있다.
#prama warning는 경고메서지를 Disable/enable 하게 할 수 있으며, #pragma checksum는 주로 ASP.NET 페이지 디버깅을 위해 만들어진 것으로 ASPX 페이지의 파일 체크섬을 생성할 때 사용된다.

아래 예제는 (1) #pragma warning을 사용하여 컴파일시 CS3021 경고를 Disable하는 예와 (2) if (false) 블럭에 대한 경고를 전체 disable 했다가 다시 enable (restore)하는 예를 든 것이다.

```cs
// CS3021 Warning을 Disable
#pragma warning disable 3021

namespace App1
{
    [System.CLSCompliant(false)] 
    class Program
    {
        static void Main(string[] args)
        {
            //...
        
#pragma warning disable
        if (false)
        {
            Console.WriteLine("TBD");
        }
#pragma warning restore
        
            //...
        }
    }
}
```

#### 기타 전처리기 지시어

#undef 는 #define과 반대로 지정된 심벌을 해제 할 때 사용한다.
#elif 는 #if와 함께 사용하여 else if를 나타낸다.
#line 은 거의 사용되진 않지만, 라인번호를 임의로 변경하거나 파일명을 임의로 다르게 설정할 수 있게 해준다.
#error 는 전처리시 Preprocessing을 중단하고 에러 메시지를 출력하게 한다.
#warning 은 경고 메서지를 출력하지만 Preprocessing은 계속 진행한다.
warning과 error는 특정 컴포넌트가 어떤 환경에서 실행되지 않아야 할 때 이를 경고나 에러를 통해 알리고자 할 때 사용될 수 있다.

아래 코드는 (1) 첫번째 예제는 Enterprise Edition이 아닌 경우 경고 메시지를 내는 것을 보여주고, (2) 두번째 예제는 Edition 심벌이 복수로 지정된 경우에 에러를 내게 하는 케이스를 예시하고 있다. 만약 여러 개의 파일들을 병합한 후, 컴파일을 해야하는 경우 이러한 에러 체크가 유용할 수 있다.

```cs
// #warning 예제 -----------------------------------
#if (!ENTERPRISE_EDITION)
#warning This class should be used in Enterprise Edition
#endif

namespace App1 {
    class EnterpriseUtility {
    }
}

// #error 예제 --------------------------------------
#define STANDARD_EDITION
#define ENTERPRISE_EDITION

#if (STANDARD_EDITION && ENTERPRISE_EDITION)
#error Use either STANDARD or ENTERPRISE edition. 
#endif

namespace App1 {
    class Class1 {
    }
}
```

## C# 고급 문법

### C# Indexer

C# Indexer는 클래스 객체의 데이타를 배열 형태로 인덱스를 써서 엑세스할 수 있게 해준다. 즉, 클래스 객체는 배열이 아님에도 불구하고, 마치 배열처럼 []를 사용하여 클래스 내의 특정 필드 데이타를 엑세스하는 것이다. 다음은 Indexer를 이용하여 문자 데이타를 클래스 객체에 넣은 예이다.

```cs
MyClass cls = new MyClass();
cls[0] = "First";
```

#### C# 인덱서 정의

C# Indexer는 특별한 문법인 this[ ] 를 써서 클래스 속성(Property)처럼 get과 set을 정의한다. 클래스 내부의 어떤 데이타를 리턴하는지는 클래스 디자인시 필요에 따라 정하게 될 것이고, 리턴 데이타 타입도 여러 가지로 지정할 수 있다.

입력 파라미터인 인덱스도 여러 데이타 타입을 쓸 수 있는데, 주로 int 나 string 타입을 사용하여 인덱스값을 주는 것이 일반적이다. 아래 예제는 간단한 인덱서 예로서, int 인덱스를 받아 배열의 데이타를 찾아 정수를 리턴하는 예이다.

```cs
class MyClass
{
   private const int MAX = 10;
   private string name;

   // 내부의 정수 배열 데이타
   private int[] data = new int[MAX];

   // 인덱서 정의. int 파라미터 사용
   public int this[int index] 
   {
      get
      {            
         if (index < 0 || index >= MAX)
         {
            throw new IndexOutOfRangeException();
         }
         else
         {
            // 정수배열로부터 값 리턴
            return data[index];
         }
      }
      set
      {
         if (!(index < 0 || index >= MAX))
         {
            // 정수배열에 값 저장
            data[index] = value;
         }
      }
   }
}

class Program
{
   static void Main(string[] args)
   {
      MyClass cls = new MyClass();

      // 인덱서 set 사용
      cls[1] = 1024;

      // 인덱서 get 사용
      int i = cls[1];
   }
}
```

### Dynamic Language Runtime

**Static Language vs Dynamic Language**

프로그래밍은 언어는, 그를 구분하는 한 방식으로, 컴파일시 Type Checking을 진행하는 Static Language (Statically Typed Language)와 런타임시 Type을 판별하는 Dynamic Language로 구분할 수 있다. 예를 들어, C#은 Static Language에 속하며, Python, Ruby, JavaScript 등은 Dynamic Language에 속한다.

C#은 기본적으로 Static Language이지만, C# 4.0에서 Dynamic Language의 요소를 추가하였다. 즉, C# 4.0 언어에서는 dynamic 이라는 키워드를 추가하였고, .NET Framework 4.0에는 DLR (Dynamic Language Runtime)를 추가함으로서 Dynamic Language가 갖는 기능을 언어와 Framework에 수용한 것이다. 따라서 .NET 4.0의 DLR을 사용하면서 다른 Dynamic Language를 함께 사용하는 것이 가능해 졌다.

#### C# dynamic 키워드

C#의 dyanmic은 C# 4.0에서 새로 도입된 키워드로서 컴파일러에게 변수의 Type을 체크하지 않도록 하고 런타임시까지는 해당 타입을 알 수 없음을 표시한다. 내부적으로 dynamic 타입은 object 타입을 사용하므로 dynamic 타입의 변수는 중간에 다른 타입의 값을 가질 수 있다. 예를 들어, dynamic 변수에 숫자를 할당했다가 나중에 다시 문자열을 할당하는 것이 가능하다. object 타입과 dynamic 타입의 차이점은 object 타입은 구체적 타입의 속성과 메서드를 사용하기 전에 반드시 캐스팅을 통해 구체적 타입으로 변경 후에 사용해야 하는 반면, dynamic 타입은 캐스팅이 없이도 직접 실제 타입(underlying type)의 메서드와 속성을 사용할 수 있다는 점이다.

```cs
// 1. dynamic은 중간에 형을 변환할 수 있다.

dynamic v = 1;
// System.Int32 출력
Console.WriteLine(v.GetType());

v = "abc";
// System.String 출력
Console.WriteLine(v.GetType());


// 2. dynamic은 cast가 필요없다

object o = 10;
// 틀린표현
// (에러: Operator '+' cannot be applied to operands of type 'object' and 'int')
o = o + 20;
// 맞는 표현: object 타입은 casting이 필요하다
o = (int)o + 20;

// dynamic 타입은 casting이 필요없다.
dynamic d = 10;
d = d + 20;
```

#### 익명타입에 dynamic 사용 예제

C# dynamic의 간단한 예제를 보이기 위해 아래 예제는 익명타입 객체를 dynamic 에 할당하고 이를 다른 클래스 메서드에 파라미터로 전달하는 예를 들었다. **dynamic은 컴파일러에게 하나의 정적 Type으로 인식되기 때문에** 메서드 원형에서도 - int나 string과 같이 - 파라미터 타입에 dynamic 이라고 지정할 수 있다. 전달된 dynamic 파라미터는 (아래 Class2.Run() 메서드에서 보듯이) 그 dynamic 객체로부터 직접 속성을 호출할 수 있다.

하지만, 이 예제 코드는 2가지 큰 제약점을 가지고 있는데, 첫째는 익명타입은 한번 생성된 후 다시 새로운 속성을 추가할 수 없고 또한 익명타입 자체가 메서드 이벤트 등을 갖지 못하기 때문에, 이러한 멤버를 동적으로 할당하여 dynamic 타입에서 추가할 수 없다. 두번째는 만약 Class2가 동일한 어셈블리가 아닌 다른 어셈블리에 놓인다면, 이 코드는 에러(object does not contain a definition for Name)를 발생시킨다. 이는 코드에서 dynamic 타입이 익명타입(underlying type)인데, 다른 어셈블리에서는 이 익명타입을 볼 수 없기 때문이다. 이러한 제약점은 모두 아래의 ExpandoObject 클래스를 사용하여 해결할 수 있다.

```cs
// 동일 어셈블리에서 익명타입에 dynamic 사용한 경우
class Class1
{
    public void Run()
    {
        dynamic t = new { Name = "Kim", Age = 25 };

        var c = new Class2();        
        c.Run(t);
    }
}

class Class2
{
    public void Run(dynamic o)
    {
        // dynamic 타입의 속성 직접 사용
        Console.WriteLine(o.Name);
        Console.WriteLine(o.Age);
    }
}
```

#### ExpandoObject 사용 예제

DLR (Dynamic Runtime Language) 네임스페이스인 System.Dynamic 에는 2개의 중요한 클래스가 있는데, 개발자가 dynamic 타입을 쉽게 생성하도록 도와주는 ExpandoObject 클래스와 보다 유연한 Customization을 위한 고급 dynamic 기능을 지원하는 DynamicObject 클래스가 그것이다. 여기서 일반적으로 많이 사용되는 ExpandoObject 클래스는 dynamic 타입에 속성, 메서드, 이벤트를 동적으로 쉽게 할당할 수 있게 도와주는 클래스이다.

사용법은 먼저 ExpandoObject 클래스로부터 객체를 생성한 후 이를 C# dynamic 변수에 할당한다. 이후 이 dynamic 타입의 변수에서 새로운 속성, 메서드 혹은 이벤트를 할당하면 된다. 메서드 할당은 델리게이트를 할당하는데, 예를 들어 아래 예제와 같이 람다식을 Delegate로 캐스팅하는 방식 등을 사용할 수 있다. 이벤트는 먼저 이벤트 필드를 NULL로 초기화 한 후 사용한다. 이벤트는 += 혹은 -= 연산자를 써서 이벤트 핸들러를 추가 혹은 제거할 수 있다. 다른 일반 타입과 마찬가지로 dynamic 타입은 파라미터로 타 메서드에 전달할 수 있으며, ExpandoObject 클래스로부터 생성된 dynamic 타입은 다른 어셈블리로 전달되는 경우에도 문제 없이 사용할 수 있다.

```cs
//ExpandoObject
public class Myclass
{
    public void M1()
    {
        // ExpandoObject에서 dynamic 타입 생성
        dynamic person = new ExpandoObject();

        // 속성 지정
        person.Name = "Kim";      
        person.Age = 10;

        // 메서드 지정
        person.Display = (Action)(() =>
        {
            Console.WriteLine("{0} {1}", person.Name, person.Age);
        });

        person.ChangeAge = (Action<int>)((age) => { 
            person.Age = age;
            if (person.AgeChanged != null)
            {
                person.AgeChanged(this, EventArgs.Empty);
            }
        });

        // 이벤트 초기화
        person.AgeChanged = null; //dynamic 이벤트는 먼저 null 초기화함

        // 이벤트핸들러 지정
        person.AgeChanged += new EventHandler(OnAgeChanged);

        // 타 메서드에 파라미터로 전달
        M2(person);
    }

    private void OnAgeChanged(object sender, EventArgs e)
    {
        Console.WriteLine("Age changed");
    }

    // dynamic 파라미터 전달받음
    public void M2(dynamic d)
    {
        // dynamic 타입 메서드 호출 
        d.Display();
        d.ChangeAge(20);
        d.Display();
    }
}
```

#### ExpandoObject의 dynamic 멤버 보기

ExpandoObject 클래스는 동적으로 추가되는 멤버들을 내부 해시테이블에 저장하고 있는데, 필요한 경우 이 정보를 IDictionary<String, Object> 인터페이스를 통해 쉽게 엑세스할 수 있다. 즉, ExpandoObject 클래스 자체가 IDictionary<String, Object> 인터페이스 구현하고 있어서 이 클래스 객체를 IDictionary<String, Object> 인터페이스로 캐스팅하여 내부 멤버 데이타를 엑세스할 수 있다. 아래 예제는 동적으로 속성, 메서드, 이벤트를 추가하고 이들을 IDictionary 인터페이스를 통해 출력해 보는 코드이다.

```cs
public void M1()
{
    dynamic person = new ExpandoObject();            
    person.Name = "Kim";
    person.Age = 10;            
    person.Display = (Action)(() => { });
    person.ChangeAge = (Action<int>)((age) => { person.Age = age; });
    person.AgeChanged = null;
    person.AgeChanged += new EventHandler((s, e) => { });

    // ExpandoObject를 IDictionary로 변환
    var dict = (IDictionary<string, object>)person;

    // person 의 속성,메서드,이벤트는
    // IDictionary 해시테이블에 저정되어 있는데
    // 아래는 이를 출력함
    foreach (var d in dict)
    {
        Console.WriteLine("{0}: {1}", d.Key, d.Value);
    }
}
```

### async / await 키워드(C# 5.0 이후)

C# 5.0부터 새로운 C# 키워드로 async와 await가 추가되었다. 이 키워드들은 기존의 비동기 프로그래밍 (asynchronous programming)을 보다 손쉽게 지원하기 위해 C# 5.0에 추가된 중요한 기능이다.

C# async는 컴파일러에게 해당 메서드가 await를 가지고 있음을 알려주는 역활을 한다. async라고 표시된 메서드는 await를 1개 이상 가질 수 있는데, 하나도 없는 경우라도 컴파일은 가능하지만 Warning 메시지가 표시된다. async를 표시한다고 해서 자동으로 비동기 방식으로 프로그램을 수행하는 것은 아니고, 일종의 보조 역활을 하는 컴파일러 지시어로 볼 수 있다. async 메서드의 리턴 타입은 대부분의 경우 Task<TResult> (리턴값이 있는 경우) 혹은 Task (리턴값이 없는 경우) 인데, 예를 들어 리턴값이 string일 경우 async Task<string> method() 와 같이 정의하고 return "문자열"과 같이 문자열만 리턴한다. C# 컴파일러는 return 문의 문자열을 자동으로 Task<string>로 변환해 준다. 또 다른 async 메서드의 리턴 타입으로 void 타입이 있는데, 특히 이벤트핸들러를 위해 void 리턴을 허용하고 있다.

실제 핵심 키워드는 await인데, 이 await는 일반적으로 Task 혹은 Task<T> 객체와 함께 사용된다. Task 이외의 클래스도 사용 가능한데, awaitable 클래스, 즉 GetAwaiter() 라는 메서드를 갖는 클래스이면 함께 사용 가능하다.

UI 프로그램에서 await는 Task와 같은 awaitable 클래스의 객체가 완료되기를 기다리는데, 여기서 중요한 점은 UI 쓰레드가 정지되지 않고 메시지 루프를 계속 돌 수 있도록 필요한 코드를 컴파일러가 await 키워드를 만나면 자동으로 추가한다는 점이다. 메시지 루프가 계속 돌게 만든다는 것은 마우스 클릭이나 키보드 입력 등과 같은 윈도우 메시지들을 계속 처리할 수 있다는 것을 의미한다. await는 해당 Task가 끝날 때까지 기다렸다가 완료 후, await 바로 다음 실행문부터 실행을 계속한다. await가 기다리는 Task 혹은 실행 메서드는 별도의 Worker Thread에서 돌 수도 있고, 또는 UI Thread에서 돌 수도 있다.

아래 예제는 버튼 클릭으로 Run()이라는 async 메서드를 실행하고, Run 메서드 안에서 비동기 Task를 만들어 실행하고 결과를 기다리는 await 문의 예를 보여주고 있다. await는 LongCalcAsync() 라는 메서드가 끝나기를 기다렸다가 끝나면 결과를 sum에 할당한 후 다음 문장들을 계속 실행한다. 특히 여기서 주목할 만한 것은 결과값을 Label 컨트롤에 뿌려줄 때, Invoke()나 BeginInvoke()를 쓸 필요가 없다는 점이다. Background Thread에서 비동기 Task가 끝난 후, await가 다시 Caller가 갖고 있던 쓰레드 즉 UI Thread로 다음 문장들을 실행하게 하기 때문이다.

```cs
// 예제1
private void button1_Click(object sender, EventArgs e)
{
     Run();  //UI Thread에서 실행
}

private async void Run()
{
    // 비동기로 Worker Thread에서 도는 task1
    // Task.Run(): .NET Framework 4.5+
    var task1 = Task.Run(() => LongCalcAsync(10));

    // task1이 끝나길 기다렸다가 끝나면 결과치를 sum에 할당
    int sum = await task1;

    // UI Thread 에서 실행
    // Control.Invoke 혹은 Control.BeginInvok 필요없음
    this.label1.Text = "Sum = " + sum;
    this.button1.Enabled = true;
}

private int LongCalcAsync(int times)
{
    int result = 0;
    for (int i = 0; i < times; i++)
    {
        result += i;
        Thread.Sleep(1000); 
    }
    return result;
}
```

#### .NET 4.5 Async 혹은 TaskAsync 메서드들

C# 5.0과 함께 선보인 .NET 4.5는 기존의 동기화(Synchronous) 메서드들과 구분하여 C#의 await (혹은 VB의 Await)를 지원하기 위해 많은 Async 메서드들을 추가하였다. 이 새 메서드들은 기본적으로 기존의 Synchronous 메서드명 뒤에 Async를 붙여 명명되었는데, 만약 기존에 Async로 끝나는 메서드가 이미 있었던 경우에는 TaskAsync를 메서드명에 붙여 명명하였다.

```cs
System.IO.Stream.Read() : 기존 동기 메서드
System.IO.Stream.ReadAsync() : 4.5 Async 메서드

WebClient.DownloadStringAsync() : 기존 비동기 메서드
WebClient.DownloadStringTaskAsync() : 4.5 TaskAsync 메서드
```

#### await : UI 쓰레드에서 도는 Task

[Advanced Topic] await가 기다리는 Task는 대부분의 경우 Background Worker Thread에서 실행된다. 하지만 await를 썼다고 해서 자동으로 그 Task(혹은 메서드)가 Worker Thread에서 도는 것은 아니다. 아래 예제는 await를 사용했지만, 해당 Task(LongCalc2)는 (별도로 Worker Thread를 생성하지 않고) UI 쓰레드에서 실행된다. 만약 Worker Thread를 생성하려면, Task.Run() 등과 메서드를 사용하여 비동기 작업을 지정할 수 있다.

```cs
// 예제3
private void button1_Click(object sender, EventArgs e)
{
     Run();  //UI Thread에서 실행
}

private async void Run()
{    
    int sum = await LongCalc2(10);
    this.label1.Text = "Sum = " + sum;
    this.button1.Enabled = true;
}

private async Task<int> LongCalc2(int times)
{
    //UI Thread에서 실행
    Debug.WriteLine(Thread.CurrentThread.ManagedThreadId);
    int result = 0;
    for (int i = 0; i < times; i++)
    {
        result += i;                
        await Task.Delay(1000);
    }
    return result;
}
```

#### await : Task.ContinueWith()

[Advanced Topic] 앞에서 이야기 하였듯이 await는 해당 Task가 끝난 후 await 문장이 있었던 곳으로부터 계속 다음 문장들을 실행하도록 되어있다. 이러한 기능은 .NET 4.0에서 소개 되었던 Task클래스의 ContinueWith()를 써서 아래와 같이 구현될 수 있다. 물론 C# 5.0 컴파일러가 await를 이렇게 변경한다는 것은 아니지만, 개념적으로 동일한 방식이라 볼 수 있다.

아래 예제에서 ContinueWith() 메서드는 첫번째 파라미터에서 task1 이 끝난 후 실행될 명령들을 람다식으로 지정하고 있다. 그리고 두번째 파라미터에는 실행블럭이 현재 쓰레드 (예제의 경우 UI Thread)에서 실행하도록 TaskScheduler.FromCurrentSynchronizationContext()를 지정하고 있다. 즉, 개념적으로 await는 특정 Task가 실행된 후 이러 이러한 실행블럭을 현재 실행 (쓰레드) 컨텍스트에서 실행하도록 하는 것이다.

```cs
// 예제4
private void Run2()
{    
    var task1 = Task<int>.Run(() => LongCalc2(10));
    
    // await task1과 동일한 효과
    //
    task1.ContinueWith(x => {
      this.label1.Text = "Sum = " + task1.Result;
      this.button1.Enabled = true;      
    }, TaskScheduler.FromCurrentSynchronizationContext());
}
```

#### 콘솔프로그램에서의 await

[Advanced Topic] 윈폼이나 WPF 같은 UI 프로그램은 await가 실행되기 전에 당시 실행되고 있는 쓰레드를 캡쳐해서 SynchronizationContext 에 가지고 있으며, await가 끝난 후에 이 컨텍스트로부터 원래 쓰레드 맥락에서 다음 문장들을 실행하게 한다. 하지만, 콘솔 프로그램이나 윈도우즈 서비스 프로그램의 경우에는 SynchronizationContext가 디폴트로 null 이 되어, await 이후의 문장들을 실행할 때 Thread Pool에서 작업 쓰레드를 가져와 실행하게 된다. 아래 예제는 awiat 실행 이전에 SynchronizationContext.Current 가 null 임을 체크하고 있으며, 또한 await 이후에 쓰레드가 작업 쓰레드임을 ManagedThreadId 속성을 통해 확인해 보는 것이다.

```cs
// 예제5
//using System;
//using System.Threading;
//using System.Threading.Tasks;

static void Main(string[] args)
{            
    Console.WriteLine("Main:" + Thread.CurrentThread.ManagedThreadId);
    Run();
    Console.ReadLine();
}

private async void Run()
{
    // 비동기로 Worker Thread에서 도는 task1
    var task1 = Task.Run(() => LongCalcAsync(10));

    // 콘솔프로그램인 경우 SynchronizationContext가 null
    Console.WriteLine(SynchronizationContext.Current);

    // task1이 끝나길 기다렸다가 끝나면 결과치를 sum에 할당
    int sum = await task1;

    // Worker Thread 에서 실행
    Console.WriteLine(sum);
    Console.WriteLine(Thread.CurrentThread.ManagedThreadId);
}

private int LongCalcAsync(int times)
{
    int result = 0;
    for (int i = 0; i < times; i++)
    {
        result += i;
        Thread.Sleep(1000); 
    }
    return result;
}
```

# 참고 문서

- http://www.csharpstudy.com/CSharp/CSharp-Intro.aspx
- https://blog.hexabrain.net/category/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%20%EA%B4%80%EB%A0%A8/C%23

